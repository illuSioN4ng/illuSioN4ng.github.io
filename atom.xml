<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>illuSioN4ng&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://illuSioN4ng.github.io/"/>
  <updated>2018-01-21T15:06:48.568Z</updated>
  <id>http://illuSioN4ng.github.io/</id>
  
  <author>
    <name>illuSioN4ng_uestc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Promise对象</title>
    <link href="http://illuSioN4ng.github.io/2018/01/21/ESx-promise/"/>
    <id>http://illuSioN4ng.github.io/2018/01/21/ESx-promise/</id>
    <published>2018-01-21T07:20:08.000Z</published>
    <updated>2018-01-21T15:06:48.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>&emsp;&emsp;<code>Promise</code> 网上有很多的JavaScript实现，ES6中将它写进了语言标准，统一了语言写法，并提供了原生的 <code>Promise</code> 对象的支持。<br>&emsp;&emsp;所谓 <code>Promise</code> 就是一个对象用来传递异步操作的信息。 <code>Promise</code> 对象有以下两个特点：    </p><ol><li>对象的状态不受外界的影响。 <code>Promise</code> 代表一种异步操作，它一共有三种状态：Pending（未完成）、Resolved（已完成，又叫fulfilled）、Rejected（已失败）。只有异步操作的结果可以决定当前是哪一种状态，任何操作都不可以改变这个状态；</li><li>一旦状态改变之后就不能再次修改，任何时候都可以得到这个结果状态。 <code>Promise</code>对象的状态改变一共有两种方式：从Pending变为Resolved，或者从Pending变为Rejected。只要其中一种发生，状态就会凝固，不会再发生改变，Promise会一直保持这个状态。</li></ol><p>&emsp;&emsp;先简单说下 <code>Promise</code> 的优缺点，有点上面已经提到了，就是可以将异步操作流程按照同步操作的流程表达出来，避免了层层嵌套的回调写法，此外， <code>Promise</code> 提供了统一的接口，使伊布流程控制更加简单。不过同样有一些缺点，比如： <code>Promise</code> 无法取消，一旦新建它就会一直执行下去，无法中途停止，其次，如果不设置回调函数的话， <code>Promise</code> 的错误不会立即被捕获，在这 <code>Promise</code> 在Pending状态的时候，我们无法得知该状态是刚开始还是即将完成，换句话说，无法得知目前状态的具体进展。    </p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>&emsp;&emsp;ES6中规定 <code>Promise</code> 是一个构造函数，用来构建 <code>Promise</code> 实例对象。下面是一个简单的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// some code here</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>) &#123;</span><br><span class="line">    resolve(value)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp; <code>Promise</code> 构造函数接受一个函数作为参数，该函数接受两个参数分别代表 <code>Resolved</code>和 <code>Rejected</code> 状态时需要执行的函数。当 <code>Promise</code> 从Pending状态变为Resolved的时候调用resolve函数，并将异步调用的结果作为参数传递给resolve函数；当从pending状态变为Rejected状态的时候执行reject函数，并将错误信息传递给reject函数。<br>&emsp;&emsp; <code>Promise</code> 实例生成之后可以使用then方法来指定Resolved状态和Rejected函数的回调函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do somthing</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle the error</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;如果调用resolve函数和reject函数时带有参数，那么这些参数可以被传递给回调函数。reject函数通常参数是Error对象的实例，表示抛出错误；resolve函数的参数除了正常的值外，还可能是一个新的promise对象，因为异步操作的结果可能是一个值也可能是另外一个异步操作，具体可以看下下面的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do somthing</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do somthin</span></span><br><span class="line">  resolve(p1)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;上面的代码中，p1和p2都是Promise的实例对象，可以看到p2中的resolve函数的参数是p1，即一个异步操作返回另一个异步操作，这种情况下，p1的状态就传递给p2。也就是说p1的状态决定p2的状态，如果p1的状态是Pending的话，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经由Pending转变为Resolved或者Rejected的话，那么p2的回调就会立即执行。    </p><h2 id="Promise-prototype-then-函数"><a href="#Promise-prototype-then-函数" class="headerlink" title="Promise.prototype.then() 函数"></a>Promise.prototype.then() 函数</h2><p>&emsp;&emsp;<code>then</code> 函数是为Promise实例添加状态改变时的毁掉函数。前面说过then函数有两个参数分别是Resolve和Reject（可选）状态的回调函数。<code>then</code> 函数返回的是一个新的Promise实例，因此可以采用链式写法，即then方法后面继续调用另外一个then方法。采用链式的then写法可以指定一组按照次序调用的函数，这时前面的的函数可能返回的还是一个Promise对象（即有异步操作），而后一个Promise实例会等待该Promise对象状态发生改变的时候再被调用。    </p><h2 id="Promise-prototype-catch-函数"><a href="#Promise-prototype-catch-函数" class="headerlink" title="Promise.prototype.catch() 函数"></a>Promise.prototype.catch() 函数</h2><p>&emsp;&emsp;Promise.prototype.catch()函数其实是.then(null, rejection)的别名，用来指定发生错误时的回调函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">getJson(<span class="string">'url.your.site/data.json'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// handle the error</span></span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">getJson(<span class="string">'url.your.site/data.json'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// handle the error</span></span><br><span class="line">      <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;一般来说，不要在then函数中定义Rejected状态的回调函数，应该在then链式调用的最后使用catch方法来做。</p><blockquote><p>catch方法返回的还是一个Promise对象，因此后面还是可以链式调用then方法</p></blockquote><h2 id="Promise-all-方法和Promise-race-方法"><a href="#Promise-all-方法和Promise-race-方法" class="headerlink" title="Promise.all()方法和Promise.race()方法"></a>Promise.all()方法和Promise.race()方法</h2><p>&emsp;&emsp;Promise.all方法用于将多个Promise实例对象包装成一个新的Promise实例。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3])</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;上述代码中 Promise.all方法接受一个数组对象作为参数，数组里面所有的元素都是一个Promise实例对象。显然p的状态是由p1、p2、p3共同决定的，分为以下两种情况：    </p><ol><li>只有三者状态都转变为Fulfilled，p的状态才会变为Fulfilled，此时p1、p2、p3三者的返回值组成一个数组，返回给p的回调函数去处理；</li><li>只要三者之间有一个是Rejected状态，p的状态就会变成Rejected，此时第一个被Rejected的实例的返回值就会返回给p的回调函数。    </li></ol><p>&emsp;&emsp;Promise.race()方法和Promise.all()方法的功能不同之处在于，race方法是只需要参数数组中最先状态状态转变为Fulfilled的Promise实例的返回值，而不是等参数数组中所有的Promise对象都转变完成之后再传递。    </p><p>&emsp;&emsp;当然Promise还是有一些其他的方法，这里就不在赘述了，如果还有兴趣，可以去查找相应的文档，深入的了解一下。    </p><blockquote><p>参阅 <a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">ES 6标准入门 Promise 相关</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;&lt;code&gt;Promise&lt;/code&gt; 网上有很多的JavaScript实现，ES6中将它写进了语言标准，统一了语
      
    
    </summary>
    
      <category term="ESx" scheme="http://illuSioN4ng.github.io/categories/ESx/"/>
    
    
      <category term="ESx" scheme="http://illuSioN4ng.github.io/tags/ESx/"/>
    
      <category term="JavaScript" scheme="http://illuSioN4ng.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Generator函数</title>
    <link href="http://illuSioN4ng.github.io/2018/01/18/ESx-generator/"/>
    <id>http://illuSioN4ng.github.io/2018/01/18/ESx-generator/</id>
    <published>2018-01-18T13:08:33.000Z</published>
    <updated>2018-01-21T15:06:48.568Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;今天在看node.js相关内容的时候，遇到了async/await函数相关，然后想到了promise、generator函数，发现有点记忆混乱了，遂准备整理一下ES6相关的东西。（实际业务中用不到的东西真的是太容易遗忘了，虽然是好东西，能够带来极大的便利，可是业务上需要兼容低版本IE的限制，真的太大了 Orz~~）</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>&emsp;&emsp;<code>Generator</code> 函数是ES6语法提供的一种异步编程解决方案，语法行为和传统函数完全不同。从语法上来看，可以简单把 <code>Generator</code> 函数理解成一个状态机，封装多个内部状态。执行 <code>Generator</code> 函数会返回一个迭代器对象，所以 <code>Generator</code> 函数除了是一个状态机还是一个迭代对象生成函数，返回的迭代器可以一次访问 <code>Generator</code> 函数内部的所有状态。<br>&emsp;&emsp;形式上， <code>Generator</code> 是一个普通函数，但是有两个特征：1、function命令与函数名之间有一个星号；2、函数体内部使用yield语句定义不同的内部状态（ <code>yield</code> 在英语中的意思就是 “产出”的意思）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'over'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hw = helloWorldGenerator();</span><br><span class="line">hw.next(); <span class="comment">// &#123;value: "hello", done: false&#125;</span></span><br><span class="line">hw.next(); <span class="comment">// &#123;value: "world", done: false&#125;</span></span><br><span class="line">hw.next(); <span class="comment">// &#123;value: "over", done: true&#125;</span></span><br><span class="line">hw.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line">hw.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;上面代码定义了一个简单的 <code>Generator</code> 函数 - <code>helloWorldGenerator</code> ，它的内部有两个 <code>yield</code> 语句 “hello” 和 “world” ,即该函数具有三个状态： hello 、 world 和 return语句。<br>&emsp;&emsp; <code>Generator</code> 函数和一般函数的调用方式相同，都是在函数名之后加上一对圆括号，不同之处在于，调用 <code>Generator</code> 函数之后该函数并不执行，返回的也不是函数的运行结果，而是一个指向内部状态的指针对象，也就是迭代器对象（Iterator Object）。<br>&emsp;&emsp; <code>Generator</code> 接下来就是执行迭代器对象的 <code>next</code> 方法，使得指针指向下一个状态，换句话说，就是每次调用<code>next</code> 方法内部指针都会从函数头部或者当前指针位置开始执行，直到遇到下一个 <code>yield</code> 语句（或者到 <code>return</code> 语句）为止。换言之， <code>Generator</code> 函数是分段执行的，<code>yield</code> 语句是暂停执行的标记，而 <code>next</code> 方法可以恢复函数的执行。<br>&emsp;&emsp;由上面的代码可以看出，当 <code>Generator</code> 函数所有状态都执行完毕之后 <code>done</code> 属性会置为 <code>true</code> ，继续执行的话，<code>value</code> 属性的值会返回 <code>undefned</code> , <code>done</code> 属性依然为 <code>true</code> 。<br>&emsp;&emsp;在ES6 中并没有规定function 关键字和函数名之间的星号写在哪个位置，这导致一下几种写法都能通过：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">foo</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>*<span class="title">foo</span> (<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;由于 <code>Generator</code> 函数仍然是普通函数，所以一般的写法推荐是上面的第一种，即星号紧跟在function关键字后面。    </p><h2 id="yield语句"><a href="#yield语句" class="headerlink" title="yield语句"></a>yield语句</h2><p>&emsp;&emsp;由于 <code>Generator</code> 函数返回的遍历器对象只有调用 <code>next</code> 方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。<code>yield</code> 语句就是暂停标志。<br>&emsp;&emsp;遍历器对象的 <code>next</code> 方法的运行逻辑如下。    </p><ol><li>遇到 <code>yield</code> 语句就暂停执行后面的操作，并将紧跟在 <code>yield</code> 后的表达式的值作为返回的对象的value属性值。    </li><li>下一次调用next方法时再继续往下执行，执行遇到下一条yield语句。</li><li>如果没有再遇到新的yield语句，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值作为返回值作为对象的value属性值。</li><li>如果该函数没有return语句，则返回的value值为undefined。<br>&emsp;&emsp;需要注意的是，yield语句后面的表达式，只有当调用next方法，内部指针指向该语句时才会执行，因此等于为JavaScript提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。    </li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">111</span> + <span class="number">222</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述代码中，yield后面的表达式 ‘111 + 222’ 不会立即求职，只会在next方法将指针移到这一句的时候才会执行并求职。<br>&emsp;&emsp;yield 和 return的相似之处在于都能返回紧跟在语句后的表达式的值。区别在于每次遇到yield函数暂停执行，下一次会继续从该位置执行，而return不具备位置记忆功能。一个函数只可以执行一次return函数，但是可以执行多个yield状态，因此 <code>Generator</code> 函数可以返回多个状态值。<br>&emsp;&emsp; <code>Generator</code> 可以不用yield语句，这时就变成了一个单纯的暂缓执行函数。<strong>另外注意</strong>，yield不能用于普通函数中，否则会报错。（SyntaxError: Unexpected number）    </p><h2 id="next-方法的参数"><a href="#next-方法的参数" class="headerlink" title="next 方法的参数"></a>next 方法的参数</h2><p>&emsp;&emsp;yield语句本身没有返回值，或者说总返回undefined。next方法可以带一个参数，该参数会被当作上一条yield语句的返回值。<br>&emsp;&emsp; <code>Generator</code> 函数从暂停状态到恢复运行，其上下文状态（context）是不变，通过next方法的参数就有办法在 <code>Generator</code> 运行后继续向函数体内注入值。可以在 <code>Generator</code> 函数运行的不同阶段，从外部向内部注入不同值，从而调整整个函数行为。可以看下下面的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">var</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = foo(<span class="number">5</span>);</span><br><span class="line">a.next() <span class="comment">// Object&#123;value:6, done:false&#125;</span></span><br><span class="line">a.next() <span class="comment">// Object&#123;value:NaN, done:false&#125;</span></span><br><span class="line">a.next() <span class="comment">// Object&#123;value:NaN, done:true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = foo(<span class="number">5</span>);</span><br><span class="line">b.next() <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line">b.next(<span class="number">6</span>) <span class="comment">// &#123; value:4, done:false &#125;</span></span><br><span class="line">b.next(<span class="number">4</span>) <span class="comment">// &#123; value:21, done:true &#125;</span></span><br></pre></td></tr></table></figure></p><blockquote><p>参阅 <a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="noopener">ES 6标准入门 Generator 相关</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;今天在看node.js相关内容的时候，遇到了async/await函数相关，然后想到了promise、generator函数，发现有点记忆混乱了，遂准备整理一下ES6相关的东西。（实际业务中用不到的东西真的是太容易遗忘了，虽然是好东西，能够带来极大的
      
    
    </summary>
    
      <category term="ESx" scheme="http://illuSioN4ng.github.io/categories/ESx/"/>
    
    
      <category term="ESx" scheme="http://illuSioN4ng.github.io/tags/ESx/"/>
    
      <category term="JavaScript" scheme="http://illuSioN4ng.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>命令模式</title>
    <link href="http://illuSioN4ng.github.io/2018/01/10/OPP-command/"/>
    <id>http://illuSioN4ng.github.io/2018/01/10/OPP-command/</id>
    <published>2018-01-10T14:13:48.000Z</published>
    <updated>2018-01-20T09:11:41.665Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<strong>命令模式（Command）</strong>：将请求与实现解耦并封装成独立对象，从而使不同的请求对客户端实现参数化；同事可以对请求排队或者记录请求日志，以及执行可撤销的操作。也就是说改模式旨在将函数的调用、请求和操作封装成一个单一的对象，然后对这个对象进行一系列的处理。<br>&emsp;&emsp;我们来通过车辆购买程序来展示这个模式，首先定义车辆购买的具体操作类：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CarManager = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求信息</span></span><br><span class="line">    requestInfo: <span class="function"><span class="keyword">function</span> (<span class="params">model, id</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'The information for '</span> + model +</span><br><span class="line">    <span class="string">' with ID '</span> + id + <span class="string">' is foobar'</span>;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 购买汽车</span></span><br><span class="line">    buyVehicle: <span class="function"><span class="keyword">function</span> (<span class="params">model, id</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'You have successfully purchased Item '</span></span><br><span class="line">    + id + <span class="string">', a '</span> + model;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组织view</span></span><br><span class="line">    arrangeViewing: <span class="function"><span class="keyword">function</span> (<span class="params">model, id</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'You have successfully booked a viewing of '</span></span><br><span class="line">    + model + <span class="string">' ( '</span> + id + <span class="string">' ) '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;来看一下上述代码，通过调用函数来简单执行manager的命令，然而在一些情况下，我们并不想直接调用对象内部的方法。这样会增加对象与对象间的依赖。现在我们来扩展一下这个CarManager 使其能够接受任何来自包括model和car ID 的CarManager对象的处理请求。根据命令模式的定义，我们希望实现如下这种功能的调用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CarManager.execute(&#123; <span class="attr">commandType</span>: <span class="string">"buyVehicle"</span>, <span class="attr">operand1</span>: <span class="string">'Ford Escort'</span>, <span class="attr">operand2</span>: <span class="string">'453543'</span> &#125;);</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;根据这样的需求，我们可以这样啦实现CarManager.execute方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CarManager.execute = <span class="function"><span class="keyword">function</span> (<span class="params">command</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CarManager[command.request](command.model, command.carID);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;改造以后，调用就简单多了，如下调用都可以实现（当然有些异常细节还是需要再完善一下的）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CarManager.execute(&#123; <span class="attr">request</span>: <span class="string">"arrangeViewing"</span>, <span class="attr">model</span>: <span class="string">'Ferrari'</span>, <span class="attr">carID</span>: <span class="string">'145523'</span> &#125;);</span><br><span class="line">CarManager.execute(&#123; <span class="attr">request</span>: <span class="string">"requestInfo"</span>, <span class="attr">model</span>: <span class="string">'Ford Mondeo'</span>, <span class="attr">carID</span>: <span class="string">'543434'</span> &#125;);</span><br><span class="line">CarManager.execute(&#123; <span class="attr">request</span>: <span class="string">"requestInfo"</span>, <span class="attr">model</span>: <span class="string">'Ford Escort'</span>, <span class="attr">carID</span>: <span class="string">'543434'</span> &#125;);</span><br><span class="line">CarManager.execute(&#123; <span class="attr">request</span>: <span class="string">"buyVehicle"</span>, <span class="attr">model</span>: <span class="string">'Ford Escort'</span>, <span class="attr">carID</span>: <span class="string">'543434'</span> &#125;);</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;命令模式比较容易设计一个命令队列，在需求的情况下比较容易将命令计入日志，并且允许接受请求的一方决定是否需要调用，而且可以实现对请求的撤销和重设，而且由于新增的具体类不影响其他的类，所以很容易实现。<br>&emsp;&emsp;但敏捷开发原则告诉我们，不要为代码添加基于猜测的、实际不需要的功能，如果不清楚一个系统是否需要命令模式，一般就不要着急去实现它，事实上，在需求的时通过重构实现这个模式并不困难，只有在真正需求如撤销、恢复操作等功能时，把原来的代码重构为命令模式才有意义。    </p><blockquote><p>参考: </p><ol><li><a href="http://www.cnblogs.com/TomXu/archive/2012/03/08/2358593.html" target="_blank" rel="noopener">http://www.cnblogs.com/TomXu/archive/2012/03/08/2358593.html</a> </li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;命令模式（Command）&lt;/strong&gt;：将请求与实现解耦并封装成独立对象，从而使不同的请求对客户端实现参数化；同事可以对请求排队或者记录请求日志，以及执行可撤销的操作。也就是说改模式旨在将函数的调用、请求和操作封装成一个单一的对
      
    
    </summary>
    
      <category term="OOP" scheme="http://illuSioN4ng.github.io/categories/OOP/"/>
    
    
      <category term="JavaScript" scheme="http://illuSioN4ng.github.io/tags/JavaScript/"/>
    
      <category term="OOP" scheme="http://illuSioN4ng.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>基于vue-cli的多页配置</title>
    <link href="http://illuSioN4ng.github.io/2018/01/08/vue-vuecli/"/>
    <id>http://illuSioN4ng.github.io/2018/01/08/vue-vuecli/</id>
    <published>2018-01-08T02:07:07.000Z</published>
    <updated>2018-01-20T09:11:41.671Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;最近因为公司中台项目前端技术栈准备整体迁移到vue上，又开始对vue-cli进行了一次相对深入的研究，为项目搭建一个简单的前端开发框架，虽然目前需求的单页应用，不过还是对基于vue-cli的多页应用的配置进行了了解，这篇文章就是进行相关的总结：   </p><h2 id="vue-cli的变化"><a href="#vue-cli的变化" class="headerlink" title="vue-cli的变化"></a>vue-cli的变化</h2><p>&emsp;&emsp;在公司直接安装vue-cli并初始化vue项目的时候，就发现文档目录还是有些许变化的，尤其是build文件夹里少了两个文件，由下面两个图可见：<br><strong>旧版的build文件夹</strong>：<br><img src="http://ww1.sinaimg.cn/large/8c55dc23gy1fn8zj6462jj208e06idfs.jpg" alt="旧版的build文件夹"><br><strong>新版的build文件夹(vue-cli@2.9.2)</strong>：<br><img src="http://ww1.sinaimg.cn/large/8c55dc23gy1fn8zkcmz9mj209005mwef.jpg" alt="新版的build文件夹"><br>&emsp;&emsp;我们知道dev-client.js和dev-server.js文件是之前webpack本地服务热重载hot-reloading，后来想到应该是版本升级之后webpack升级之后使用 <code>webpack-dev-server</code> 进行本地服务的构建了。<br>&emsp;&emsp;打开package.json文件来看：<br><strong>旧版 package.json</strong>:<br><img src="http://ww1.sinaimg.cn/large/8c55dc23gy1fn90jo14erj20ey04mmx8.jpg" alt="旧版 package.json"><br><strong>新版(vue-cli@2.9.2) package.json</strong>：<br><img src="http://ww1.sinaimg.cn/large/8c55dc23gy1fn90k7tws1j20r904q0sv.jpg" alt="新版(vue-cli@2.9.2) package.json"><br>&emsp;&emsp;一看便知，新版 <code>npm run dev</code> 启动的命令与旧版完全不一样了，这也就是为什么新版少了两个文件的原因，新版切换到 <code>webpack-dev-server</code> 来启动本地浏览器。<br>&emsp;&emsp;同时，新版本地服务 <code>npm start</code> 之后浏览器并没有自动打开，显然是配置被默认关闭了，我们改如何去找呢？<br>&emsp;&emsp;首先按照命令调用的js去看 <code>webpack.dev.conf.js</code>：<br><img src="http://ww1.sinaimg.cn/large/8c55dc23gy1fn90xjgspjj20q507jdge.jpg" alt="webpack.dev.conf.js"><br>&emsp;&emsp;这个config又是哪儿来的呢？<br><img src="http://ww1.sinaimg.cn/large/8c55dc23gy1fn90yjeqj1j20fc05lmxi.jpg" alt="webpack.dev.conf.js"><br>&emsp;&emsp;再去看 <code>config</code> 文件夹下的 <code>index.js</code> 文件：<br><img src="http://ww1.sinaimg.cn/large/8c55dc23gy1fn910lmdyqj20w80b4751.jpg" alt="config/index.js"><br>&emsp;&emsp;在这里把 <code>autoOpenBrowser</code> 置为 <code>true</code> 我们在去启动服务（命令行 <code>npm start</code>），这时候浏览器就会自动打开了。    </p><h2 id="基于vue-cli的多页应用配置"><a href="#基于vue-cli的多页应用配置" class="headerlink" title="基于vue-cli的多页应用配置"></a>基于vue-cli的多页应用配置</h2><p>&emsp;&emsp;因为vue-cli默认的就是单页应用的配置，这里就不在赘述。下面详细说下，搭建的多页应用的过程。</p><ol><li><p>首先全局安装<a href="https://github.com/vuejs/vue-cli" target="_blank" rel="noopener">vue-cli</a>    </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i vue-cli -g</span><br></pre></td></tr></table></figure></li><li><p>创建<a href="https://github.com/vuejs-templates" target="_blank" rel="noopener">项目模板</a>：官方提供了六个模板 <code>webpack</code> 、<code>pwa</code> 、 <code>webpack-simple</code> 、 <code>browserify</code> 、 <code>browserify-simple</code> 、 <code>simple</code> ，选择webpack模板    </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack &lt;project-name&gt;</span><br></pre></td></tr></table></figure></li><li><p>在安装过程中会有一些提示：</p><ul><li>Vue build这个选项选择Runtime + Compiler<br><img src="http://ww1.sinaimg.cn/large/8c55dc23gy1fn91ojm8bjj20v604st8y.jpg" alt="Runtime + Compiler"></li><li>安装vue-router，ESLint、Karma+Mocha、Nightwatch根据需求选择安装<br><img src="http://ww1.sinaimg.cn/large/8c55dc23gy1fn91otxqf5j20jh091t95.jpg" alt="其他安装选项"></li><li>安装好依赖之后，根据提示操作，即可成功启动项目    </li></ul></li><li><p>现在创建的项目模板是单页面应用，与多页面应用还有些差别，需要做一些调整：</p><ul><li>项目目录结构调整<br><strong>单页目录</strong>：<br><img src="http://ww1.sinaimg.cn/large/8c55dc23gy1fn952pr92pj20a80dlmxb.jpg" alt="单页目录"><br><strong>多页目录</strong>：<br><img src="http://ww1.sinaimg.cn/large/8c55dc23gy1fn9534vizsj20ah0gjt90.jpg" alt="多页目录"><br>在开发路径src下增加modules和pages文件夹，分别存放模块和页面<br>有关页面的所有文件都放到同一文件夹下就近管理：<code>index.html</code>(页面模板)、<code>main.js</code>(页面入口文件)、<code>App.vue</code>(页面使用的组件，公用组件放到components文件夹下)都移到index文件夹下，并把<code>main.js</code>改为<code>index.js</code>,保证页面的入口js文件和模板文件的名称一致，同时，新建test文件夹（test页面）（多页应用不需要安装<code>vue-router</code>）    </li><li><p>在build/utils.js中添加<code>entries</code>、<code>htmlPlugin</code>两个方法：webpack多入口文件和多页面输出    </p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> PAGE_PATH = path.resolve(__dirname, <span class="string">'../src/pages'</span>)</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'../config'</span>)</span><br><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> packageConfig = <span class="built_in">require</span>(<span class="string">'../package.json'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多入口配置</span></span><br><span class="line">exports.entries = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> entryFiles = glob.sync(PAGE_PATH + <span class="string">'/*/*.js'</span>)</span><br><span class="line">  <span class="keyword">var</span> map = &#123;&#125;</span><br><span class="line">  entryFiles.forEach(<span class="function">(<span class="params">filePath</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> filename = filePath.substring(filePath.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>, filePath.lastIndexOf(<span class="string">'.'</span>))</span><br><span class="line">    map[filename] = filePath</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多页面输出配置</span></span><br><span class="line">exports.htmlPlugin = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> entryHtml = glob.sync(PAGE_PATH + <span class="string">'/*/*.html'</span>)</span><br><span class="line">  <span class="keyword">let</span> arr = []</span><br><span class="line">  entryHtml.forEach(<span class="function">(<span class="params">filePath</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> filename = filePath.substring(filePath.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>, filePath.lastIndexOf(<span class="string">'.'</span>))</span><br><span class="line">    <span class="keyword">let</span> conf = &#123;</span><br><span class="line">      template: filePath,</span><br><span class="line">      filename: filename + <span class="string">'.html'</span>,</span><br><span class="line">      chunks: [ filename ],</span><br><span class="line">      inject: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">      conf = merge(conf, &#123;</span><br><span class="line">        chunks: [ <span class="string">'manifest'</span>, <span class="string">'vendor'</span>, filename ], <span class="comment">//插件对页面入口文件(即js文件)的限定，如果不设置则会把整个项目下的所有入口文件全部引入</span></span><br><span class="line">        <span class="comment">// vendor模块是指提取涉及node_modules中的公共模块</span></span><br><span class="line">        <span class="comment">// manifest模块是对vendor模块做的缓存</span></span><br><span class="line">        minify: &#123;</span><br><span class="line">          removeComments: <span class="literal">true</span>,</span><br><span class="line">          collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">          removeAttributeQuotes: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        chunksSortMode: <span class="string">'dependency'</span> <span class="comment">// 插件会按照模块的依赖关系依次加载，即：manifest，vendor，本页面入口，其他页面入口</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    arr.push(<span class="keyword">new</span> HtmlWebpackPlugin(conf))</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li><li><p>修改build/webpack.base.conf.js的入口配置</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  context: path.resolve(__dirname, <span class="string">'../'</span>),</span><br><span class="line">  <span class="comment">// entry: &#123;</span></span><br><span class="line">  <span class="comment">//   app: './src/main.js'</span></span><br><span class="line">  <span class="comment">// &#125;,</span></span><br><span class="line">  entry: utils.entries(),</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure></li><li><p>修改build/webpack.dev.conf.js和build/webpack.prod.conf.js的多页面配置：把原有的页面模板配置注释或删除，并把多页面配置添加到plugins<br><code>webpack.dev.conf.js</code>:    </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      <span class="string">'process.env'</span>: <span class="built_in">require</span>(<span class="string">'../config/dev.env'</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line">    <span class="keyword">new</span> webpack.NamedModulesPlugin(), <span class="comment">// HMR shows correct file names in console on update.</span></span><br><span class="line">    <span class="keyword">new</span> webpack.NoEmitOnErrorsPlugin(),</span><br><span class="line">    <span class="comment">// https://github.com/ampedandwired/html-webpack-plugin</span></span><br><span class="line">    <span class="comment">// new HtmlWebpackPlugin(&#123;</span></span><br><span class="line">    <span class="comment">//   filename: 'index.html',</span></span><br><span class="line">    <span class="comment">//   template: 'index.html',</span></span><br><span class="line">    <span class="comment">//   inject: true</span></span><br><span class="line">    <span class="comment">// &#125;),</span></span><br><span class="line">    ...utils.htmlPlugin(),</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><code>webpack.prod.conf.js</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">......</span><br><span class="line">  <span class="comment">// generate dist index.html with correct asset hash for caching.</span></span><br><span class="line">  <span class="comment">// you can customize output by editing /index.html</span></span><br><span class="line">  <span class="comment">// see https://github.com/ampedandwired/html-webpack-plugin</span></span><br><span class="line">  <span class="comment">// new HtmlWebpackPlugin(&#123;</span></span><br><span class="line">  <span class="comment">//   filename: config.build.index,</span></span><br><span class="line">  <span class="comment">//   template: 'index.html',</span></span><br><span class="line">  <span class="comment">//   inject: true,</span></span><br><span class="line">  <span class="comment">//   minify: &#123;</span></span><br><span class="line">  <span class="comment">//     removeComments: true,</span></span><br><span class="line">  <span class="comment">//     collapseWhitespace: true,</span></span><br><span class="line">  <span class="comment">//     removeAttributeQuotes: true</span></span><br><span class="line">  <span class="comment">//     // more options:</span></span><br><span class="line">  <span class="comment">//     // https://github.com/kangax/html-minifier#options-quick-reference</span></span><br><span class="line">  <span class="comment">//   &#125;,</span></span><br><span class="line">  <span class="comment">//   // necessary to consistently work with multiple chunks via CommonsChunkPlugin</span></span><br><span class="line">  <span class="comment">//   chunksSortMode: 'dependency'</span></span><br><span class="line">  <span class="comment">// &#125;),</span></span><br><span class="line">  ...utils.htmlPlugin(),</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>&emsp;&emsp;至此，多页面应用已经搭建完毕，只需要在pages文件夹创建相应的页面文件即可，如输入 <code>loaclhost:8080/test.html</code> 即打开 <code>test</code> 文件夹对应的页面，以此类推。<br>&emsp;&emsp;当然，某些业务需求对于url可能需要定制，这时候就需要用到 <code>connect-history-api-fallback</code> api中的 <code>rewrites</code> (<a href="https://github.com/bripkens/connect-history-api-fallback#rewrites" target="_blank" rel="noopener">详情请点击</a>) 选项，如下图配置，就可以实现输入 <code>loaclhost:8080/test</code> 即打开 <code>test</code> 文件夹对应的页面,以及404页面:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  clientLogLevel: <span class="string">'warning'</span>,</span><br><span class="line">  historyApiFallback: &#123;</span><br><span class="line">    <span class="comment">// index: '/test.html', //path.join(config.dev.assetsPublicPath, '/test.html')</span></span><br><span class="line">    <span class="comment">// rewrites: [ &#123; from: /.*/, to: path.join(config.dev.assetsPublicPath, '/index.html') &#125; ]</span></span><br><span class="line">    <span class="comment">// 路由配置，前后端统一</span></span><br><span class="line">    <span class="comment">// 默认 '/' 对应 index.html</span></span><br><span class="line">    rewrites: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">from</span>: <span class="regexp">/^\/test$/</span>,</span><br><span class="line">        to: <span class="string">'/test.html'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">from</span>: <span class="regexp">/.*/</span>,</span><br><span class="line">        to: <span class="string">'/404.html'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;最近因为公司中台项目前端技术栈准备整体迁移到vue上，又开始对vue-cli进行了一次相对深入的研究，为项目搭建一个简单的前端开发框架，虽然目前需求的单页应用，不过还是对基于vue-cli的多页应用的配置进行了了解，这篇文章就是进行相关的总结：   
      
    
    </summary>
    
      <category term="vue" scheme="http://illuSioN4ng.github.io/categories/vue/"/>
    
    
      <category term="JavaScript" scheme="http://illuSioN4ng.github.io/tags/JavaScript/"/>
    
      <category term="vue" scheme="http://illuSioN4ng.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>观察者模式</title>
    <link href="http://illuSioN4ng.github.io/2018/01/07/OOP-observer/"/>
    <id>http://illuSioN4ng.github.io/2018/01/07/OOP-observer/</id>
    <published>2018-01-07T07:19:46.000Z</published>
    <updated>2018-01-20T09:11:41.664Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<strong>观察者模式又叫发布订阅模式（Publish/Subscribe）</strong>，它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。<br>&emsp;&emsp;使用观察者模式的好处：    </p><ol><li>支持简单的广播通信，自动通知所有已经订阅过的对象。</li><li>页面载入后目标对象很容易与观察者存在一种动态关联，增加了灵活性。</li><li>目标对象与观察者之间的抽象耦合关系能够单独扩展以及重用。</li></ol><p>&emsp;&emsp;下面看一个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用代码</span></span><br><span class="line"><span class="keyword">var</span> observer = &#123;</span><br><span class="line">    <span class="comment">//订阅</span></span><br><span class="line">    addSubscriber: <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subscribers[<span class="keyword">this</span>.subscribers.length] = callback;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//退订</span></span><br><span class="line">    removeSubscriber: <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.subscribers.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.subscribers[i] === callback) &#123;</span><br><span class="line">                <span class="keyword">delete</span> (<span class="keyword">this</span>.subscribers[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//发布</span></span><br><span class="line">    publish: <span class="function"><span class="keyword">function</span> (<span class="params">what</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.subscribers.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.subscribers[i] === <span class="string">'function'</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.subscribers[i](what);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 将对象o具有观察者功能</span></span><br><span class="line">    make: <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">            o[i] = <span class="keyword">this</span>[i];</span><br><span class="line">            o.subscribers = [];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后订阅2个对象blogger和user，使用observer.make方法将这2个对象具有观察者功能，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> blogger = &#123;</span><br><span class="line">    writeBlogPost:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> content = <span class="string">'Today is '</span> + <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        <span class="keyword">this</span>.publish(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> la_times = &#123;</span><br><span class="line">    newIssue:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> paper = <span class="string">'Martians have landed on Earth!'</span>;</span><br><span class="line">        <span class="keyword">this</span>.publish(paper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">observer.make(blogger);</span><br><span class="line">observer.make(la_times);</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;使用方法就比较简单了，订阅不同的回调函数，以便可以注册到不同的观察者对象里（也可以同时注册到多个观察者对象里）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jack = &#123;</span><br><span class="line">    read:<span class="function"><span class="keyword">function</span> (<span class="params">what</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'I just read that '</span> + what)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> jill = &#123;</span><br><span class="line">    gossip:<span class="function"><span class="keyword">function</span> (<span class="params">what</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'You didn\'t hear it from me, but '</span> + what)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">blogger.addSubscriber(jack.read);</span><br><span class="line">blogger.addSubscriber(jill.gossip);</span><br><span class="line">blogger.writeBlogPost();    <span class="comment">// I just read that Today is Sun Jan 07 2018 15:38:54 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="comment">// You didn't hear it from me, but Today is Sun Jan 07 2018 15:38:54 GMT+0800 (中国标准时间)</span></span><br><span class="line">blogger.removeSubscriber(jill.gossip);</span><br><span class="line">blogger.writeBlogPost();    <span class="comment">// I just read that Today is Sun Jan 07 2018 15:39:46 GMT+0800 (中国标准时间)</span></span><br><span class="line">la_times.addSubscriber(jill.gossip);</span><br><span class="line">la_times.newIssue();    <span class="comment">// You didn't hear it from me, but Martians have landed on Earth!</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;观察者的使用场合就是：当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象需要改变的时候，就应该考虑使用观察者模式。<br>&emsp;&emsp;总的来说，观察者模式所做的工作就是在解耦，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化。    </p><blockquote><p>参考: </p><ol><li><a href="https://book.douban.com/subject/26382780/" target="_blank" rel="noopener">JavaScript设计模式与开发实践</a> </li><li><a href="https://book.douban.com/subject/26589719/" target="_blank" rel="noopener">JavaScript设计模式</a> </li><li><a href="https://github.com/shichuan/javascript-patterns/blob/master/design-patterns/observer.html" target="_blank" rel="noopener">https://github.com/shichuan/javascript-patterns/blob/master/design-patterns/observer.html</a></li><li><a href="http://www.cnblogs.com/TomXu/archive/2012/03/02/2355128.html" target="_blank" rel="noopener">http://www.cnblogs.com/TomXu/archive/2012/03/02/2355128.html</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;观察者模式又叫发布订阅模式（Publish/Subscribe）&lt;/strong&gt;，它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。&lt;b
      
    
    </summary>
    
      <category term="OOP" scheme="http://illuSioN4ng.github.io/categories/OOP/"/>
    
    
      <category term="JavaScript" scheme="http://illuSioN4ng.github.io/tags/JavaScript/"/>
    
      <category term="OOP" scheme="http://illuSioN4ng.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>迭代器模式</title>
    <link href="http://illuSioN4ng.github.io/2018/01/06/OOP-iterator/"/>
    <id>http://illuSioN4ng.github.io/2018/01/06/OOP-iterator/</id>
    <published>2018-01-06T07:49:56.000Z</published>
    <updated>2018-01-20T09:11:41.664Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<strong>迭代器模式(Iterator)</strong>：提供一种方法顺序一个聚合对象中各个元素，而又不暴露该对象内部表示。<br>&emsp;&emsp;迭代器的几个特点是：    </p><ol><li>访问一个聚合对象的内容而无需暴露它的内部表示。</li><li>为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。</li><li>遍历的同时更改迭代器所在的集合结构可能会导致问题（比如C#的foreach里不允许修改item）。    </li></ol><p>&emsp;&emsp;一般的迭代，至少要有2个方法，hasNext()和Next()，这样才做做到遍历所有对象，可以看下面的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> agg = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span>,</span><br><span class="line">    data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">    length = data.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> element;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            element = data[index];</span><br><span class="line">            index = index + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> element;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        hasNext: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index &lt; length;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        rewind: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        current: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data[index];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">&#125; ());</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;使用方法如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代的结果是：1,3,5</span></span><br><span class="line"><span class="keyword">while</span> (agg.hasNext()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(agg.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;也可以调用重置方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重置</span></span><br><span class="line">agg.rewind();</span><br><span class="line"><span class="built_in">console</span>.log(agg.current()); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;迭代器的使用场景是：对于集合内部结果常常变化各异，我们不想暴露其内部结构的话，但又响让客户代码透明底访问其中的元素，这种情况下我们可以使用迭代器模式。</p><blockquote><p>参考: </p><ol><li><a href="https://book.douban.com/subject/26382780/" target="_blank" rel="noopener">JavaScript设计模式与开发实践</a> </li><li><a href="https://book.douban.com/subject/26589719/" target="_blank" rel="noopener">JavaScript设计模式</a> </li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;迭代器模式(Iterator)&lt;/strong&gt;：提供一种方法顺序一个聚合对象中各个元素，而又不暴露该对象内部表示。&lt;br&gt;&amp;emsp;&amp;emsp;迭代器的几个特点是：    &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;访问一个聚合对象的内容而无需暴
      
    
    </summary>
    
      <category term="OOP" scheme="http://illuSioN4ng.github.io/categories/OOP/"/>
    
    
      <category term="JavaScript" scheme="http://illuSioN4ng.github.io/tags/JavaScript/"/>
    
      <category term="OOP" scheme="http://illuSioN4ng.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>回顾我的2017，展望我的2018</title>
    <link href="http://illuSioN4ng.github.io/2017/12/31/%E5%9B%9E%E9%A1%BE%E6%88%91%E7%9A%842017%EF%BC%8C%E5%B1%95%E6%9C%9B%E6%88%91%E7%9A%842018/"/>
    <id>http://illuSioN4ng.github.io/2017/12/31/回顾我的2017，展望我的2018/</id>
    <published>2017-12-31T07:50:30.000Z</published>
    <updated>2018-01-20T09:11:41.672Z</updated>
    
    <content type="html"><![CDATA[<p>今天是17年最后一天，按照惯例做下年终总结：    </p><h2 id="16年初和17年初定下的目标，和完成的情况"><a href="#16年初和17年初定下的目标，和完成的情况" class="headerlink" title="16年初和17年初定下的目标，和完成的情况"></a>16年初和17年初定下的目标，和完成的情况</h2><h3 id="16年目标"><a href="#16年目标" class="headerlink" title="16年目标"></a>16年目标</h3><ol><li>顺利拿到实习offer（估计要去得和老板撕逼）；<strong>去京东作为前端实习生</strong></li><li>泸沽湖去一次，不去实习的话估计三四月哥们会过来；<strong>没有去成，猴年也没有去峨眉山，蛮遗憾的</strong></li><li>去帝都见见世面，见一次大海，见一见在北方那些可爱的人们；<strong>借着360前端星的机会去了北京，没有见到海，也没有见到想见的人们</strong></li><li>继续运动，目标135，八块腹肌；<strong>15年冬天膝盖受伤之后一直没有跑步，运动的量也减少了，好在坚持篮球，也开始健身了</strong></li><li>继续坚持读书的习惯，读一些让自己轻松的书；<strong><a href="https://book.douban.com/people/illuSioN4ng/collect" target="_blank" rel="noopener">书单</a>  <a href="https://movie.douban.com/people/illuSioN4ng/collect" target="_blank" rel="noopener">电影清单</a></strong></li><li>不脱单，因为不可能所有的都实现，做人不能贪心，对吧？<strong>failed</strong></li></ol><h3 id="17年目标"><a href="#17年目标" class="headerlink" title="17年目标"></a>17年目标</h3><ol><li>顺利毕业；<strong>当然毕业啦</strong></li><li>继续坚持锻炼，体重控制到140； <strong>毕业前差点就到了，工作之后又又又又胖了Orz~</strong></li><li>坚持读书，坚持在豆瓣上记录自己的阅读以及观影列表；（10本技术类，20本非技术类的书籍）<strong>(今年总共读了<a href="https://book.douban.com/people/illuSioN4ng/collect" target="_blank" rel="noopener">书单</a>) 技术类的完整的只有六本吧，还有很多在读的书以及想读的书，来年一定要都读完，读了很多的其他类别的书，感觉收获还是很多的，继续加油</strong></li><li>七月份入职之后，能够胜任自己的工作，爱岗敬业吧；<strong>工作还算顺利</strong></li><li>毕业之后，搬进新家，布置自己的书房，好好生活，带着妈妈旅游两次；<strong>完全没有时间去旅游，希望来年可以更好的陪家人吧</strong></li><li>学习计划的话，可能视情况而定吧，初步是将16年很多想要了解的东西都在毕业前熟悉一下；<strong>工作中对于前端的思考还蛮多的，来年一定要更加多的思考相关的东西，有更好的职业发展道路</strong></li><li>如果可以的话，工作后，希望能给自己买个单反，记录生活的美好。<strong>用奖学金买了微单，但是吃灰比较多~</strong></li><li>对于感情，不奢求了Orz~~~~<strong>嘻嘻，她出现了，挺好</strong></li></ol><h2 id="17年的总结"><a href="#17年的总结" class="headerlink" title="17年的总结"></a>17年的总结</h2><p>毕业季没啥好写的，感觉是至今最有意思的一段经历了。都记在心里啦~<br>然后就是工作上的事情，没有多少意外的事情，感觉和自己之前想到的情况还蛮相似的，希望能够破局，前端工程化、前端工作流、适用于教育BG业务的前端框架、前端工程持续集成、前端监控等等都是我们现在需要去摸索的东西，不知道明年会怎样，要给自己压力去做一些事情，death or rising from the ashes again。<br>读书学习上面还是挺满意的吧，豆瓣书单逐渐变得多起来了。技术类的学习还是在进行，主要依旧是系统性的学习前端还有框架，依旧没有跳出前端，走向编程这个大的领域，希望明年能够走出来并且能够做的更多吧。博客上半年几乎没有怎么动，下半年只有到后期比较闲的时候才开始整，明年加油吧。<br><img src="http://ww1.sinaimg.cn/large/8c55dc23gy1fn00h1lhiij20kd05cdfw.jpg" alt="github contributions last year"></p><h2 id="17年的目标"><a href="#17年的目标" class="headerlink" title="17年的目标"></a>17年的目标</h2><ol><li>工作上能够更加主动，希望能够承担起领导对于自己的期待，以及让自己更加充实起来，给自己压力，逼迫自己去成长；</li><li>生活上，心态更加平和吧，把工作生活学习三者更加好的结合起来，不要彼此影响太多，希望自己更加成熟吧；</li><li>布置好自己的工作台，期待了很久很久了；</li><li>读书方面，读完自己囤的一堆书，找一些经济学、行为学的书来读，扩展自己的知识面吧，不要被别人幸存者偏差误导，对生活对未来要有着自己的更加体系化的判断；</li><li>好好经营自己和笨笨的感情吧，很乖巧的一个女孩。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天是17年最后一天，按照惯例做下年终总结：    &lt;/p&gt;
&lt;h2 id=&quot;16年初和17年初定下的目标，和完成的情况&quot;&gt;&lt;a href=&quot;#16年初和17年初定下的目标，和完成的情况&quot; class=&quot;headerlink&quot; title=&quot;16年初和17年初定下的目标，和
      
    
    </summary>
    
      <category term="年终总结" scheme="http://illuSioN4ng.github.io/categories/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="2017总结 &amp;&amp; 2018展望" scheme="http://illuSioN4ng.github.io/tags/2017%E6%80%BB%E7%BB%93-2018%E5%B1%95%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>代理模式</title>
    <link href="http://illuSioN4ng.github.io/2017/12/24/OOP-proxy/"/>
    <id>http://illuSioN4ng.github.io/2017/12/24/OOP-proxy/</id>
    <published>2017-12-24T14:22:45.000Z</published>
    <updated>2018-01-20T09:11:41.665Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<strong>代理模式（Proxy）</strong>：由于一个对象不能直接引用另一个对象，所以需要通过迭代对象在两个对象之间起到中介的作用。<br>&emsp;&emsp;实际的编程中， 因为性能问题使用代理模式的机会是非常多的。比如频繁的访问dom节点, 频繁的请求远程资源. 可以把操作先存到一个缓冲区, 然后自己选择真正的触发时机。<br>&emsp;&emsp;还有个例子就是在调用ajax请求的时候，无论是各种开源库，还是自己写的Ajax类, 都会给xhr对象设置一个代理. 我们不可能频繁的去操作xhr对象发请求, 而应该是这样。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = Ajax.get( <span class="string">'cgi.xx.com/xxx'</span> );</span><br><span class="line">request.send();</span><br><span class="line">request.done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp; 代理对象可以完全解决被代理对象与外界对象之间的耦合，当然从被代理的页面角度来看是一种保护代理，而从服务器角度来看是一种远程代理。除了上述的几种应用外，还有以下一些常用的应用场景：<br>代理模式一般适用于如下场合：</p><ol><li>远程代理，也就是为了一个对象在不同的地址空间提供局部代表，这样可以隐藏一个对象存在于不同地址空间的事实，就像web service里的代理类一样。</li><li>虚拟代理，根据需要创建开销很大的对象，通过它来存放实例化需要很长时间的真实对象，比如浏览器的渲染的时候先显示问题，而图片可以慢慢显示（就是通过虚拟代理代替了真实的图片，此时虚拟代理保存了真实图片的路径和尺寸。</li><li>安全代理，用来控制真实对象访问时的权限，一般用于对象应该有不同的访问权限。</li><li>智能指引，只当调用真实的对象时，代理处理另外一些事情。例如C#里的垃圾回收，使用对象的时候会有引用次数，如果对象没有引用了，GC就可以回收它了。</li></ol><blockquote><p>参考: </p><ol><li><a href="https://book.douban.com/subject/26382780/" target="_blank" rel="noopener">JavaScript设计模式与开发实践</a> </li><li><a href="https://book.douban.com/subject/26589719/" target="_blank" rel="noopener">JavaScript设计模式</a> </li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;代理模式（Proxy）&lt;/strong&gt;：由于一个对象不能直接引用另一个对象，所以需要通过迭代对象在两个对象之间起到中介的作用。&lt;br&gt;&amp;emsp;&amp;emsp;实际的编程中， 因为性能问题使用代理模式的机会是非常多的。比如频繁的访问d
      
    
    </summary>
    
      <category term="OOP" scheme="http://illuSioN4ng.github.io/categories/OOP/"/>
    
    
      <category term="JavaScript" scheme="http://illuSioN4ng.github.io/tags/JavaScript/"/>
    
      <category term="OOP" scheme="http://illuSioN4ng.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="http://illuSioN4ng.github.io/2017/12/17/OOP-strategy/"/>
    <id>http://illuSioN4ng.github.io/2017/12/17/OOP-strategy/</id>
    <published>2017-12-17T06:02:56.000Z</published>
    <updated>2018-01-20T09:11:41.665Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在我们的实际业务中经常会遇到很多分支判断的情况，包括商城根据用户会员等级的促销折扣、根据绩效等级的年终奖金计算，这些情况下的每种分支的业务都是类似的，只是对于具体业务的具体处理过程或者算法的不同，导致最终的效果不同。各分支之间都是平级关系，这种情况下我们可以采用策略模式，来解决算法和使用者之间的耦合。<br>&emsp;&emsp;策略模式的定义是：定义一系列的算法，把它们一个一个封装起来，并且使它们可以相互替换。    </p><h2 id="使用策略模式计算奖金"><a href="#使用策略模式计算奖金" class="headerlink" title="使用策略模式计算奖金"></a>使用策略模式计算奖金</h2><h3 id="最原始的代码实现"><a href="#最原始的代码实现" class="headerlink" title="最原始的代码实现"></a>最原始的代码实现</h3><p>&emsp;&emsp;我们编写一个名为 <code>calculateBonus</code> 的函数来计算每个人的年终奖金。显然，改函数需要两个参数：员工的工资数额和他的绩效考核等级。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> calculateBonus = <span class="function"><span class="keyword">function</span>(<span class="params"> performanceLevel, salary </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( performanceLevel === <span class="string">'S'</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( performanceLevel === <span class="string">'A'</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( performanceLevel === <span class="string">'B'</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">calculateBonus( <span class="string">'B'</span>, <span class="number">20000</span> ); <span class="comment">// 返回：40000</span></span><br><span class="line">calculateBonus( <span class="string">'S'</span>, <span class="number">6000</span> ); <span class="comment">// 返回：24000</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可以看出元时代吗中存在着显而易见的缺点：</p><ul><li><code>calculateBonus</code> 函数会随着绩效考核等级的增加而不断变得臃肿起来， <code>if-else</code> 语句会越变越多；</li><li><code>calculateBonus</code> 函数缺乏弹性，每增加一种绩效等级或者是改变一个绩效等级的奖金系数，我们都必须深入到函数内部去进行查找并修改；</li><li>函数的复用性差。</li></ul><p>&emsp;&emsp;因此我们就需要重构这一部分代码。</p><h3 id="使用组合函数的方式重构代码"><a href="#使用组合函数的方式重构代码" class="headerlink" title="使用组合函数的方式重构代码"></a>使用组合函数的方式重构代码</h3><p>&emsp;&emsp;重构最简单的方式就是使用组合函数来进行，我们把各种算法封装到一个一个的小函数中，使用一些良好的命名规范，可以一目了然地知道它对应的算法，他们也可以复用到程序的其他地方。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> performanceS = <span class="function"><span class="keyword">function</span>(<span class="params"> salary </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> performanceA = <span class="function"><span class="keyword">function</span>(<span class="params"> salary </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> performanceB = <span class="function"><span class="keyword">function</span>(<span class="params"> salary </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> calculateBonus = <span class="function"><span class="keyword">function</span>(<span class="params"> performanceLevel, salary </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( performanceLevel === <span class="string">'S'</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> performanceS( salary );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( performanceLevel === <span class="string">'A'</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> performanceA( salary );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( performanceLevel === <span class="string">'B'</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> performanceB( salary );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">calculateBonus( <span class="string">'A'</span> , <span class="number">10000</span> ); <span class="comment">// 返回：30000</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;采用组合函数的方式我们解决了功能复用的问题，但是还是没有解决函数变得越来越臃肿的可能以及缺乏弹性的事实。</p><h3 id="使用策略模式"><a href="#使用策略模式" class="headerlink" title="使用策略模式"></a>使用策略模式</h3><p>&emsp;&emsp;正如上文中提到的策略模式的定义：定义一系列的算法，把它们一个一个封装起来。将不变与变的部分隔离开是每个设计模式的主题，策略模式也不例外，策略模式的目的就是将函数的使用和函数的实现隔离开。<br>&emsp;&emsp;一个基于策略模式的程序至少由两部分组成，第一部分是预测策略类，用来封装具体的算法，并负责计算过程；第二部分是环境<code>context</code>类，接受到用户的请求后，随后将该请求委托给具体的某一个策略类。所以在 <code>context</code> 中要维持对某个策略对象的引用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> performanceS = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">performanceS.prototype.calculate = <span class="function"><span class="keyword">function</span>(<span class="params"> salary </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> performanceA = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">performanceA.prototype.calculate = <span class="function"><span class="keyword">function</span>(<span class="params"> salary </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> performanceB = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">performanceB.prototype.calculate = <span class="function"><span class="keyword">function</span>(<span class="params"> salary </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来定义奖金类Bonus：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Bonus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.salary = <span class="literal">null</span>; <span class="comment">// 原始工资</span></span><br><span class="line">    <span class="keyword">this</span>.strategy = <span class="literal">null</span>; <span class="comment">// 绩效等级对应的策略对象</span></span><br><span class="line">&#125;;</span><br><span class="line">Bonus.prototype.setSalary = <span class="function"><span class="keyword">function</span>(<span class="params"> salary </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.salary = salary; <span class="comment">// 设置员工的原始工资</span></span><br><span class="line">&#125;;</span><br><span class="line">Bonus.prototype.setStrategy = <span class="function"><span class="keyword">function</span>(<span class="params"> strategy </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.strategy = strategy; <span class="comment">// 设置员工绩效等级对应的策略对象</span></span><br><span class="line">&#125;;</span><br><span class="line">Bonus.prototype.getBonus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 取得奖金数额</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.strategy.calculate( <span class="keyword">this</span>.salary ); <span class="comment">// 把计算奖金的操作委托给对应的策略对象</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bonus = <span class="keyword">new</span> Bonus();</span><br><span class="line">bonus.setSalary( <span class="number">10000</span> );</span><br><span class="line"></span><br><span class="line">bonus.setStrategy( <span class="keyword">new</span> performanceS() ); <span class="comment">// 设置策略对象</span></span><br><span class="line"><span class="built_in">console</span>.log( bonus.getBonus() ); <span class="comment">// 输出：40000</span></span><br><span class="line">bonus.setStrategy( <span class="keyword">new</span> performanceA() ); <span class="comment">// 设置策略对象</span></span><br><span class="line"><span class="built_in">console</span>.log( bonus.getBonus() ); <span class="comment">// 输出：30000</span></span><br><span class="line"><span class="string">``</span><span class="string">`    </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&amp;emsp;&amp;emsp;上文中的 `</span>context<span class="string">` 类就是 `</span>bonus<span class="string">` ， `</span>performanceX<span class="string">` 类就是一个策略类，代表绩效等级 `</span>X<span class="string">` 的策略方法。    </span></span><br><span class="line"><span class="string">&amp;emsp;&amp;emsp;虽然已经对于代码进行了相应的重构，不过该段代码是基于传统的面向对象语言来实现的，在 `</span>JavaScript<span class="string">` 中有更加简单的方式去实现。    </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## JavaScript中的策略模式</span></span><br><span class="line"><span class="string">&amp;emsp;&amp;emsp;Talk is cheap,show you code.    </span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="keyword">var</span> strategies = &#123;</span><br><span class="line"><span class="string">"S"</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> salary </span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> salary * <span class="number">4</span>;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"A"</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> salary </span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> salary * <span class="number">3</span>;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"B"</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> salary </span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> salary * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> calculateBonus = <span class="function"><span class="keyword">function</span>(<span class="params"> level, salary </span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> strategies[ level ]( salary );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( calculateBonus( <span class="string">'S'</span>, <span class="number">20000</span> ) ); <span class="comment">// 输出：80000</span></span><br><span class="line"><span class="built_in">console</span>.log( calculateBonus( <span class="string">'A'</span>, <span class="number">10000</span> ) ); <span class="comment">// 输出：30000</span></span><br></pre></td></tr></table></figure><h2 id="策略模式的优缺点"><a href="#策略模式的优缺点" class="headerlink" title="策略模式的优缺点"></a>策略模式的优缺点</h2><p>&emsp;&emsp;测试模式是一种有效的设计模式，在上述的描述中，我们不难看出策略模式的一些优缺点。    </p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>策略模式利用组合、委托和多态等技术和思想，可以有效地避免多重条件选择语句；</li><li>策略模式封装了一些策略类，将算法封装在独立的 <code>strategy</code> 中，使得它们之间易切换、理解、扩展；</li><li>策略模式中的策略类易于复用，从而避免了许多复制粘贴修改的工作；</li><li>使用组合和委托来让 <code>context</code> 类拥有执行算法的能力，这也是继承的一种更有效的替代方案。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>选择使用的 <code>strategy</code> 的决定权在用户，所以用户必须了解所有的 <code>strategy</code> 的作用，这样才能找到一个合适的 <code>strategy</code> ，这增加了使用成本；</li><li>因为策略模式中的 <code>strategy</code> 都是独立封装的，所以一些复杂算法中处理相同逻辑部分也不能公用，所以我们需要采用一些其他的方案来辅助。</li></ul><blockquote><p>参考: </p><ol><li><a href="https://book.douban.com/subject/26382780/" target="_blank" rel="noopener">JavaScript设计模式与开发实践</a> </li><li><a href="https://book.douban.com/subject/26589719/" target="_blank" rel="noopener">JavaScript设计模式</a> </li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;在我们的实际业务中经常会遇到很多分支判断的情况，包括商城根据用户会员等级的促销折扣、根据绩效等级的年终奖金计算，这些情况下的每种分支的业务都是类似的，只是对于具体业务的具体处理过程或者算法的不同，导致最终的效果不同。各分支之间都是平级关系，这种情况下
      
    
    </summary>
    
      <category term="OOP" scheme="http://illuSioN4ng.github.io/categories/OOP/"/>
    
    
      <category term="JavaScript" scheme="http://illuSioN4ng.github.io/tags/JavaScript/"/>
    
      <category term="OOP" scheme="http://illuSioN4ng.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://illuSioN4ng.github.io/2017/12/03/OOP-singleleton/"/>
    <id>http://illuSioN4ng.github.io/2017/12/03/OOP-singleleton/</id>
    <published>2017-12-03T08:11:45.000Z</published>
    <updated>2018-01-20T09:11:41.665Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;单例模式的定义为：保证一个类只有一个实例，并提供一个访问它的全局访问点。<br>&emsp;&emsp;单例模式的经典实现方式是，创建一个类，这个类包含一个方法，这个方法在没有对象存在的情况下，将会创建一个新的实例对象。如果对象存在，这个方法只是返回这个对象的引用。<br>&emsp;&emsp;单例模式是一种常用的模式，有一些对象我们往往只允许一个存在，例如：线程池、全局缓存、浏览器中的window对象和node中的global对象等等。还有实际开发中的某个登录框弹框，并非所有用户都是需要登录的，所以我们并不见得需要将弹出框布局写死在HTML中，只需要在JavaScript中第一次登录请求的时候的时时候写入且仅写入一次。<br>&emsp;&emsp;下面我们来看一下最简单的一种单例模式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mySingleton = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Instance stores a reference to the Singleton</span></span><br><span class="line">  <span class="keyword">var</span> instance;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有方法和变量</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateMethod</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"I am private"</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="string">"Im also private"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> privateRandomNumber = <span class="built_in">Math</span>.random();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 共有方法和变量</span></span><br><span class="line">      publicMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"The public can see me!"</span> );</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      publicProperty: <span class="string">"I am also public"</span>,</span><br><span class="line"></span><br><span class="line">      getRandomNumber: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> privateRandomNumber;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果存在获取此单例实例，如果不存在创建一个单例实例</span></span><br><span class="line">    getInstance: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ( !instance ) &#123;</span><br><span class="line">        instance = init();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;返回的<code>getInstance</code>函数中判断<code>if ( !instance )</code>这步操作就是判断实例是否存在，从而控制实例只有一个。如果存在实例的话就返回该实例的引用。   </p><blockquote><p>参考: </p><ol><li><a href="https://book.douban.com/subject/26382780/" target="_blank" rel="noopener">JavaScript设计模式与开发实践</a> </li><li><a href="https://book.douban.com/subject/26589719/" target="_blank" rel="noopener">JavaScript设计模式</a> </li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;单例模式的定义为：保证一个类只有一个实例，并提供一个访问它的全局访问点。&lt;br&gt;&amp;emsp;&amp;emsp;单例模式的经典实现方式是，创建一个类，这个类包含一个方法，这个方法在没有对象存在的情况下，将会创建一个新的实例对象。如果对象存在，这个方法只是返回
      
    
    </summary>
    
      <category term="OOP" scheme="http://illuSioN4ng.github.io/categories/OOP/"/>
    
    
      <category term="JavaScript" scheme="http://illuSioN4ng.github.io/tags/JavaScript/"/>
    
      <category term="OOP" scheme="http://illuSioN4ng.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>underscore-js源码阅读（3）</title>
    <link href="http://illuSioN4ng.github.io/2017/11/12/underscore-js%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%883%EF%BC%89/"/>
    <id>http://illuSioN4ng.github.io/2017/11/12/underscore-js源码阅读（3）/</id>
    <published>2017-11-12T07:16:28.000Z</published>
    <updated>2018-01-20T09:11:41.671Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;今天准备来写一下 <code>underscore.js</code> 里面判断两个参数相等的 <code>_.isEqual</code> 函数。这里的相等的含义，简单举例来说就是 <code>1</code> 和 <code>new Number(1)</code> 被认为是 <code>equal</code>，<code>[1]</code> 和 <code>[1]</code> 也被认为是 <code>equal</code>（尽管它们的引用并不相同），当然，两个引用相同的对象肯定是 equal 的了。<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Perform a deep comparison to<span class="built_in"> check </span>if two objects are equal.</span><br><span class="line">  _.isEqual = function(a, b) &#123;</span><br><span class="line">   <span class="built_in"> return </span>eq(a, b);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><p>&emsp;由上面的代码可以看出，主要的实现是在 <code>eq</code> 函数中。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">eq = <span class="function"><span class="keyword">function</span>(<span class="params">a, b, aStack, bStack</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Identical objects are equal. `0 === -0`, but they aren't identical.</span></span><br><span class="line">    <span class="comment">// See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).</span></span><br><span class="line">    <span class="comment">//这里恒等判断中要注意 0 === -0，但是我们认为他们是不相等的</span></span><br><span class="line">    <span class="keyword">if</span> (a === b) <span class="keyword">return</span> a !== <span class="number">0</span> || <span class="number">1</span> / a === <span class="number">1</span> / b;</span><br><span class="line">    <span class="comment">// `null` or `undefined` only equal to itself (strict comparison).</span></span><br><span class="line">    <span class="comment">//这里是判断 a 或者 b 中有 `null` 或者 `undefined` 的情况，直接返回 `false`</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span> || b == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// `NaN`s are equivalent, but non-reflexive.</span></span><br><span class="line">    <span class="comment">// `NaN` 在js中是不相等的，但是我们在这里视为相等</span></span><br><span class="line">    <span class="keyword">if</span> (a !== a) <span class="keyword">return</span> b !== b;</span><br><span class="line">    <span class="comment">// Exhaust primitive checks</span></span><br><span class="line">    <span class="comment">// 这里这部分没太懂，以后来填坑</span></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">type</span> = <span class="keyword">typeof</span> a;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">type</span> !== <span class="string">'function'</span> &amp;&amp; <span class="keyword">type</span> !== <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> b != <span class="string">'object'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> deepEq(a, b, aStack, bStack);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><p>&emsp;接下来返回一个 <code>deepEq</code> 函数利用 <code>Object.prototype.toString.call</code> 来判断对象类型，如下所示：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Internal recursive comparison function for `isEqual`.</span></span><br><span class="line">  deepEq = <span class="function"><span class="keyword">function</span><span class="params">(a, b, aStack, bStack)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Unwrap any wrapped objects.</span></span><br><span class="line">    <span class="keyword">if</span> (a <span class="keyword">instanceof</span> _) a = a._wrapped;</span><br><span class="line">    <span class="keyword">if</span> (b <span class="keyword">instanceof</span> _) b = b._wrapped;</span><br><span class="line">    <span class="comment">// Compare `[[Class]]` names.</span></span><br><span class="line">    <span class="keyword">var</span> className = toString.call(a);</span><br><span class="line">    <span class="keyword">if</span> (className !== toString.call(b)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">switch</span> (className) &#123;</span><br><span class="line">      <span class="comment">// Strings, numbers, regular expressions, dates, and booleans are compared by value.</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'[object RegExp]'</span>:</span><br><span class="line">      <span class="comment">// RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')</span></span><br><span class="line">      <span class="comment">// 将正则表达式转换成字符串进行比较</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'[object String]'</span>:</span><br><span class="line">        <span class="comment">// Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is</span></span><br><span class="line">        <span class="comment">// equivalent to `new String("5")`.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span> + a === <span class="string">''</span> + b;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'[object Number]'</span>:</span><br><span class="line">        <span class="comment">// `NaN`s are equivalent, but non-reflexive.</span></span><br><span class="line">        <span class="comment">// Object(NaN) is equivalent to NaN.</span></span><br><span class="line">        <span class="keyword">if</span> (+a !== +a) <span class="keyword">return</span> +b !== +b;</span><br><span class="line">        <span class="comment">// An `egal` comparison is performed for other numeric values.</span></span><br><span class="line">        <span class="keyword">return</span> +a === <span class="number">0</span> ? <span class="number">1</span> / +a === <span class="number">1</span> / b : +a === +b;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'[object Date]'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'[object Boolean]'</span>:</span><br><span class="line">        <span class="comment">// Coerce dates and booleans to numeric primitive values. Dates are compared by their</span></span><br><span class="line">        <span class="comment">// millisecond representations. Note that invalid dates with millisecond representations</span></span><br><span class="line">        <span class="comment">// of `NaN` are not equivalent.</span></span><br><span class="line">        <span class="comment">// 数字和boolean均转换成数字进行比较</span></span><br><span class="line">        <span class="keyword">return</span> +a === +b;</span><br><span class="line">        <span class="comment">// 这里还新增了对于 `Symbol` 的支持</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'[object Symbol]'</span>:</span><br><span class="line">        <span class="keyword">return</span> SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组和对象的比较，就运用到了递归的运用了，有些许复杂，用心去理解就好啦</span></span><br><span class="line">    <span class="keyword">var</span> areArrays = className === <span class="string">'[object Array]'</span>;</span><br><span class="line">    <span class="keyword">if</span> (!areArrays) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> a != <span class="string">'object'</span> || <span class="keyword">typeof</span> b != <span class="string">'object'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Objects with different constructors are not equivalent, but `Object`s or `Array`s</span></span><br><span class="line">      <span class="comment">// from different frames are.</span></span><br><span class="line">      <span class="keyword">var</span> aCtor = a.constructor, bCtor = b.constructor;</span><br><span class="line">      <span class="keyword">if</span> (aCtor !== bCtor &amp;&amp; !(_.isFunction(aCtor) &amp;&amp; aCtor <span class="keyword">instanceof</span> aCtor &amp;&amp;</span><br><span class="line">                               _.isFunction(bCtor) &amp;&amp; bCtor <span class="keyword">instanceof</span> bCtor)&amp;&amp; </span><br><span class="line">                              (<span class="string">'constructor'</span> <span class="keyword">in</span> a &amp;&amp; <span class="string">'constructor'</span> <span class="keyword">in</span> b)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Assume equality for cyclic structures. The algorithm for detecting cyclic</span></span><br><span class="line">    <span class="comment">// structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initializing stack of traversed objects.</span></span><br><span class="line">    <span class="comment">// It's done here since we only need them for objects and arrays comparison.</span></span><br><span class="line">    aStack = aStack || [];</span><br><span class="line">    bStack = bStack || [];</span><br><span class="line">    <span class="keyword">var</span> length = aStack.length;</span><br><span class="line">    <span class="keyword">while</span> (length--) &#123;</span><br><span class="line">      <span class="comment">// Linear search. Performance is inversely proportional to the number of</span></span><br><span class="line">      <span class="comment">// unique nested structures.</span></span><br><span class="line">      <span class="keyword">if</span> (aStack[length] === a) <span class="keyword">return</span> bStack[length] === b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the first object to the stack of traversed objects.</span></span><br><span class="line">    aStack.push(a);</span><br><span class="line">    bStack.push(b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recursively compare objects and arrays.</span></span><br><span class="line">    <span class="keyword">if</span> (areArrays) &#123;</span><br><span class="line">      <span class="comment">// Compare array lengths to determine if a deep comparison is necessary.</span></span><br><span class="line">      length = a.length;</span><br><span class="line">      <span class="keyword">if</span> (length !== b.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">// Deep compare the contents, ignoring non-numeric properties.</span></span><br><span class="line">      <span class="keyword">while</span> (length--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!eq(a[length], b[length], aStack, bStack)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Deep compare objects.</span></span><br><span class="line">      <span class="keyword">var</span> keys = _.keys(a), key;</span><br><span class="line">      length = keys.length;</span><br><span class="line">      <span class="comment">// Ensure that both objects contain the same number of properties before comparing deep equality.</span></span><br><span class="line">      <span class="keyword">if</span> (_.keys(b).length !== length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">while</span> (length--) &#123;</span><br><span class="line">        <span class="comment">// Deep compare each member</span></span><br><span class="line">        key = keys[length];</span><br><span class="line">        <span class="keyword">if</span> (!(_.has(b, key) &amp;&amp; eq(a[key], b[key], aStack, bStack))) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Remove the first object from the stack of traversed objects.</span></span><br><span class="line">    aStack.pop();</span><br><span class="line">    bStack.pop();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><p>&emsp;这部分的内容基本上也就说完了，仅仅记录一下自己注意到的东西，也有很多不太清楚的细节处理，慢慢积累吧，以后会回来补坑的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;今天准备来写一下 &lt;code&gt;underscore.js&lt;/code&gt; 里面判断两个参数相等的 &lt;code&gt;_.isEqual&lt;/code&gt; 函数。这里的相等的含义，简单举例来说就是 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;new Number(1)&lt;/c
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://illuSioN4ng.github.io/categories/JavaScript/"/>
    
    
      <category term="underscore.js" scheme="http://illuSioN4ng.github.io/tags/underscore-js/"/>
    
  </entry>
  
  <entry>
    <title>jpg、png、gif的不同</title>
    <link href="http://illuSioN4ng.github.io/2017/10/26/jpg%E3%80%81png%E3%80%81gif%E7%9A%84%E4%B8%8D%E5%90%8C/"/>
    <id>http://illuSioN4ng.github.io/2017/10/26/jpg、png、gif的不同/</id>
    <published>2017-10-26T13:43:38.000Z</published>
    <updated>2018-01-20T09:11:41.669Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这一周在工作中切图的时候，随手切了个png格式的图片作为banner图，后来被告知太大，然后突然发现自己好像没有认真的总结过图片格式之间的区别，记忆中的东西也很模糊了，所以针对性的找了下资料。</p><h2 id="有损vs无损"><a href="#有损vs无损" class="headerlink" title="有损vs无损"></a>有损vs无损</h2><p>&emsp;&emsp;图片文件格式有可能会对图片的文件大小进行不同程度的压缩，图片的压缩分为有损压缩和无损压缩两种。</p><ul><li>有损压缩。指在压缩文件大小的过程中，损失了一部分图片的信息，也即降低了图片的质量，并且这种损失是不可逆的，我们不可能从有一个有损压缩过的图片中恢复出全来的图片。常见的有损压缩手段，是按照一定的算法将临近的像素点进行合并。</li><li>无损压缩。只在压缩文件大小的过程中，图片的质量没有任何损耗。我们任何时候都可以从无损压缩过的图片中恢复出原来的信息。</li></ul><h2 id="索引色vs直接色"><a href="#索引色vs直接色" class="headerlink" title="索引色vs直接色"></a>索引色vs直接色</h2><p>&emsp;&emsp;计算机在表示颜色的时候，有两种形式，一种称作索引颜色(<a href="https://en.wikipedia.org/wiki/Indexed_color" target="_blank" rel="noopener">Index Color</a>)，一种称作直接颜色(<a href="https://en.wikipedia.org/wiki/Color_depth#Direct_color" target="_blank" rel="noopener">Direct Color</a>)。</p><ul><li>索引色。用一个数字来代表（索引）一种颜色，在存储图片的时候，存储一个数字的组合，同时存储数字到图片颜色的映射。这种方式只能存储有限种颜色，通常是256种颜色，对应到计算机系统中，使用一个字节的数字来索引一种颜色。</li><li>直接色。使用四个数字来代表一种颜色，这四个数字分别代表这个颜色中红色、绿色、蓝色以及透明度。现在流行的显示设备可以在这四个维度分别支持256种变化，所以直接色可以表示2的32次方种颜色。当然并非所有的直接色都支持这么多种，为压缩空间使用，有可能只有表达红、绿、蓝的三个数字，每个数字也可能不支持256种变化之多。    </li></ul><h2 id="点阵图vs矢量图"><a href="#点阵图vs矢量图" class="headerlink" title="点阵图vs矢量图"></a>点阵图vs矢量图</h2><ul><li>点阵图，也叫做位图，像素图。构成点阵图的最小单位是象素，位图就是由象素阵列的排列来实现其显示效果的，每个象素有自己的颜色信息，在对位图图像进行编辑操作的时候，可操作的对象是每个象素，我们可以改变图像的色相、饱和度、明度，从而改变图像的显示效果。点阵图缩放会失真，用最近非常流行的沙画来比喻最恰当不过，当你从远处看的时候，画面细腻多彩，但是当你靠的非常近的时候，你就能看到组成画面的每粒沙子以及每个沙粒的颜色。</li><li>矢量图，也叫做向量图。矢量图并不纪录画面上每一点的信息，而是纪录了元素形状及颜色的算法，当你打开一付矢量图的时候，软件对图形象对应的函数进行运算，将运算结果[图形的形状和颜色]显示给你看。无论显示画面是大还是小，画面上的对象对应的算法是不变的，所以，即使对画面进行倍数相当大的缩放，其显示效果仍然相同(不失真)。</li></ul><h2 id="BMP"><a href="#BMP" class="headerlink" title="BMP"></a>BMP</h2><p>&emsp;&emsp;BitMap的缩写，是无损的、既支持索引色也支持直接色的、点阵图。<br>&emsp;&emsp;这是一种比较老的图片格式。BMP是无损的，但同时这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常具有较大的文件大小。虽然同时支持索引色和直接色是一个优点，但是太大的文件格式格式导致它几乎没有用武之地，现在除了在Windows操作系统中还比较常见之外，我们几乎看不到它。</p><h2 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a>GIF</h2><p>&emsp;&emsp;全称Graphics Interchange Format，采用LZW压缩算法进行编码。是无损的、采用索引色的、点阵图。<br>&emsp;&emsp;GIF是无损的，采用GIF格式保存图片不会降低图片质量。但得益于数据的压缩，GIF格式的图片，其文件大小要远小于BMP格式的图片。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但，GIF格式仅支持8bit的索引色，即在整个图片中，只能存在256种不同的颜色。<br>&emsp;&emsp;GIF格式适用于对色彩要求不高同时需要文件体积较小的场景，比如企业Logo、线框类的图等。因其体积小的特点，现在GIF被广泛的应用在各类网站中。</p><h2 id="JPEG"><a href="#JPEG" class="headerlink" title="JPEG"></a>JPEG</h2><p>&emsp;&emsp;JPEG是有损的、采用直接色的、点阵图。<br>&emsp;&emsp;JPEG图片格式的设计目标，是在不影响人类可分辨的图片质量的前提下，尽可能的压缩文件大小。这意味着JPEG去掉了一部分图片的原始信息，也即是进行了有损压缩。JPEG的图片的优点，是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，用来表达更生动的图像效果，比如颜色渐变。<br>&emsp;&emsp;与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。</p><h2 id="PNG-8"><a href="#PNG-8" class="headerlink" title="PNG-8"></a>PNG-8</h2><p>&emsp;&emsp;PNG全称Portable Network Graphics，PNG-8是PNG的索引色版本。PNG-8是无损的、使用索引色的、点阵图。<br>&emsp;&emsp;PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。 现在，除非需要动画的支持，否则我们没有理由使用GIF而不是PNG-8。当然了，PNG-8本身也是支持动画的，只是浏览器支持得不好，不像GIF那样受到广泛的支持。</p><h2 id="PNG-24"><a href="#PNG-24" class="headerlink" title="PNG-24"></a>PNG-24</h2><p>&emsp;&emsp;PNG-24是PNG的直接色版本。PNG-24是无损的、使用直接色的、点阵图。<br>&emsp;&emsp;无损的、使用直接色的点阵图，听起来非常像BMP，是的，从显示效果上来看，PNG-24跟BMP没有不同。PNG-24的优点在于，它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。<br>&emsp;&emsp;虽然PNG-24的一个很大的目标，是替换JPEG的使用。但一般而言，PNG-24的文件大小是JPEG的五倍之多，而显示效果则通常只能获得一点点提升。所以，只有在你不在乎图片的文件体积，而想要最好的显示效果时，才应该使用PNG-24格式。<br>&emsp;&emsp;另外，PNG-24跟PNG-8一样，是支持图片透明度的。</p><h2 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h2><p>&emsp;&emsp;全称Scalable Vector Graphics，是无损的、矢量图。<br>&emsp;&emsp;SVG跟上面这些图片格式最大的不同，是SVG是矢量图。这意味着SVG图片由直线和曲线以及绘制它们的方法组成。当你放大一个SVG图片的时候，你看到的还是线和曲线，而不会出现像素点。这意味着SVG图片在放大时，不会失真，所以它非常适合用来绘制企业Logo、Icon等。<br>&emsp;&emsp;SVG是很多种矢量图中的一种，它的特点是使用XML来描述图片。借助于前几年XML技术的流行，SVG也流行了很多。使用XML的优点是，任何时候你都可以把它当做一个文本文件来对待，也就是说，你可以非常方便的修改SVG图片，你所需要的只需要一个文本编辑器。</p><h2 id="WebP"><a href="#WebP" class="headerlink" title="WebP"></a>WebP</h2><p>&emsp;&emsp;WebP是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的、点阵图。<br>&emsp;&emsp;从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。    </p><ul><li>在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；    </li><li>在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；    </li><li>WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。<br>&emsp;&emsp;想象Web上的图片之多，百分之几十的提升，是非常非常大的优化。只可惜，目前只有Chrome浏览器和Opera浏览器支持WebP格式，所以WebP的应用并不广泛。为了使用更先进的技术，比如WebP图片格式，来压缩互联网上传输的数据流量，谷歌甚至提供了Chrome Data Compression Proxy，设置了Chrome Data Compression Proxy作为Web代理之后，你访问的所有网站中的图片，在经过Proxy的时候，都会被转换成WebP格式，以降低图片文件的大小。<br><strong><a href="https://www.zhihu.com/question/20028452/answer/142593276" target="_blank" rel="noopener">参考知乎问答</a></strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;这一周在工作中切图的时候，随手切了个png格式的图片作为banner图，后来被告知太大，然后突然发现自己好像没有认真的总结过图片格式之间的区别，记忆中的东西也很模糊了，所以针对性的找了下资料。&lt;/p&gt;
&lt;h2 id=&quot;有损vs无损&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="CSS" scheme="http://illuSioN4ng.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://illuSioN4ng.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>underscore.js源码阅读（2）</title>
    <link href="http://illuSioN4ng.github.io/2017/10/23/underscore-js%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%882%EF%BC%89/"/>
    <id>http://illuSioN4ng.github.io/2017/10/23/underscore-js源码阅读（2）/</id>
    <published>2017-10-23T13:52:47.000Z</published>
    <updated>2018-01-20T09:11:41.671Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;今天看了下underscore中的restArgs函数和createAssigner函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Similar to ES6's rest param </span></span><br><span class="line"><span class="comment">//(http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)</span></span><br><span class="line"><span class="comment">// This accumulates the arguments passed into an array, after a given index.</span></span><br><span class="line"><span class="comment">// 和ES6中的rest特性相似，根据给定参数的索引位置，将参数填充到索引之后的位置上</span></span><br><span class="line"><span class="comment">//（参见 https://github.com/jashkenas/underscore/issues/2542）</span></span><br><span class="line">  <span class="keyword">var</span> restArgs = <span class="function"><span class="keyword">function</span>(<span class="params">func, startIndex</span>) </span>&#123;</span><br><span class="line">    startIndex = startIndex == <span class="literal">null</span> ? func.length - <span class="number">1</span> : +startIndex; </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> length = <span class="built_in">Math</span>.max(<span class="built_in">arguments</span>.length - startIndex, <span class="number">0</span>),</span><br><span class="line">          rest = <span class="built_in">Array</span>(length),</span><br><span class="line">          index = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (; index &lt; length; index++) &#123;</span><br><span class="line">        rest[index] = <span class="built_in">arguments</span>[index + startIndex];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">switch</span> (startIndex) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> func.call(<span class="keyword">this</span>, rest);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> func.call(<span class="keyword">this</span>, <span class="built_in">arguments</span>[<span class="number">0</span>], rest);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> func.call(<span class="keyword">this</span>, <span class="built_in">arguments</span>[<span class="number">0</span>], <span class="built_in">arguments</span>[<span class="number">1</span>], rest);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">var</span> args = <span class="built_in">Array</span>(startIndex + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; startIndex; index++) &#123;</span><br><span class="line">        args[index] = <span class="built_in">arguments</span>[index];</span><br><span class="line">      &#125;</span><br><span class="line">      args[startIndex] = rest;</span><br><span class="line">      <span class="keyword">return</span> func.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<code>createAssigner</code>函数主要是用在下面三个地方：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Extend a given object with all the properties in passed-in object(s).</span></span><br><span class="line">  <span class="literal">_</span>.extend = createAssigner(<span class="literal">_</span>.allKeys);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Assigns a given object with all the own properties in the passed-in object(s).</span></span><br><span class="line">  <span class="comment">// (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)</span></span><br><span class="line">  <span class="literal">_</span>.extendOwn = <span class="literal">_</span>.assign = createAssigner(<span class="literal">_</span>.keys);</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Fill in a given object with default properties.</span></span><br><span class="line">  <span class="literal">_</span>.defaults = createAssigner(<span class="literal">_</span>.allKeys, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp; <code>_.extend</code> 函数是用来干扩展对象属性的函数；而 <code>_.extendOwn</code> 函数则只会对象自身已有属性； <code>_.defaults</code> 函数则是，如果 key 相同，后面的不会覆盖前面的，取第一次出现某 key 的 value，为 key-value 键值对。<br>&emsp;&emsp;除此之外，三个方法都能接受 &gt;= 1 个参数，以 .extend 为例，.extend(a, b, c) 将会将 b，c 两个对象的键值对分别覆盖到 a 上。    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An internal function for creating assigner functions.</span></span><br><span class="line"><span class="comment">// 用于实现分配器功能的内部函数</span></span><br><span class="line">  <span class="keyword">var</span> createAssigner = <span class="function"><span class="keyword">function</span>(<span class="params">keysFunc, defaults</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回函数</span></span><br><span class="line">    <span class="comment">// 经典闭包（defaults 参数在返回的函数中被引用）</span></span><br><span class="line">    <span class="comment">// 返回的函数参数个数 &gt;= 1</span></span><br><span class="line">    <span class="comment">// 将第二个开始的对象参数的键值对 "继承" 给第一个参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> length = <span class="built_in">arguments</span>.length;</span><br><span class="line">      <span class="comment">// 只传入了一个参数（或者 0 个？）</span></span><br><span class="line">      <span class="comment">// 或者传入的第一个参数是 null</span></span><br><span class="line">      <span class="keyword">if</span> (defaults) obj = <span class="built_in">Object</span>(obj);</span><br><span class="line">      <span class="keyword">if</span> (length &lt; <span class="number">2</span> || obj == <span class="literal">null</span>) <span class="keyword">return</span> obj;</span><br><span class="line">      <span class="comment">// 枚举第一个参数除外的对象参数</span></span><br><span class="line">      <span class="comment">// 即 arguments[1], arguments[2] ...</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">1</span>; index &lt; length; index++) &#123;</span><br><span class="line">        <span class="keyword">var</span> source = <span class="built_in">arguments</span>[index],</span><br><span class="line">        <span class="comment">// 提取对象参数的 keys 值</span></span><br><span class="line">        <span class="comment">// keysFunc 参数表示 _.keys </span></span><br><span class="line">        <span class="comment">// 或者 _.allKeys</span></span><br><span class="line">            keys = keysFunc(source),</span><br><span class="line">            l = keys.length;</span><br><span class="line">        <span class="comment">// 遍历该对象的键值对</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> key = keys[i];</span><br><span class="line">            <span class="comment">// _.extend 和 _.extendOwn 方法</span></span><br><span class="line">            <span class="comment">// 没有传入 defaults 参数，即 !defaults 为 true</span></span><br><span class="line">            <span class="comment">// 即肯定会执行 obj[key] = source[key] </span></span><br><span class="line">            <span class="comment">// 后面对象的键值对直接覆盖 obj</span></span><br><span class="line">            <span class="comment">// ==========================================</span></span><br><span class="line">            <span class="comment">// _.defaults 方法，defaults 参数为 true</span></span><br><span class="line">            <span class="comment">// 即 !defaults 为 false</span></span><br><span class="line">            <span class="comment">// 那么当且仅当 obj[key] 为 undefined 时才覆盖</span></span><br><span class="line">            <span class="comment">// 即如果有相同的 key 值，取最早出现的 value 值</span></span><br><span class="line">            <span class="comment">// _.defaults 中有相同 key 的也是一样取首次出现的</span></span><br><span class="line">            <span class="keyword">if</span> (!defaults || obj[key] === <span class="keyword">void</span> <span class="number">0</span>) obj[key] = source[key];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 返回已经继承后面对象参数属性的第一个参数对象</span></span><br><span class="line">      <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;今天看了下underscore中的restArgs函数和createAssigner函数&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://illuSioN4ng.github.io/categories/JavaScript/"/>
    
    
      <category term="underscore.js" scheme="http://illuSioN4ng.github.io/tags/underscore-js/"/>
    
  </entry>
  
  <entry>
    <title>underscore.js源码阅读（1）</title>
    <link href="http://illuSioN4ng.github.io/2017/10/13/underscore-js%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%881%EF%BC%89/"/>
    <id>http://illuSioN4ng.github.io/2017/10/13/underscore-js源码阅读（1）/</id>
    <published>2017-10-13T02:27:18.000Z</published>
    <updated>2018-01-20T09:11:41.670Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;最近开始看一些传统前端框架和库的源码，包括<code>Bootstrap underscore</code>等，准备在2017年刚步入工作的这半年里面能够有时间阅读完，同时能够将阅读过程中的收获记录下来。</p><pre><code>阅读一些著名框架类库的源码，就好像和一个个大师对话，你会学到很多。为什么是 underscore？最主要的原因是 underscore 简短精悍（约 1.5k 行），封装了 100 多个有用的方法，耦合度低，非常适合逐个方法阅读，适合楼主这样的 JavaScript 初学者。从中，你不仅可以学到用 void 0 代替 undefined 避免 undefined 被重写等一些小技巧 ，也可以学到变量类型判断、函数节流&amp;函数去抖等常用的方法，还可以学到很多浏览器兼容的 hack，更可以学到作者的整体设计思路以及 API 设计的原理（向后兼容）。    </code></pre><p>&emsp;&emsp;上面这段话引自<a href="https://github.com/hanzichi/underscore-analysis/issues" target="_blank" rel="noopener">hanzichi</a>，以后关于underscore.js的源码阅读的过程应该会借鉴他的文章。当然也不会仅仅局限于他的文章啦(#^.^#)。<br>&emsp;&emsp;这篇文章首先来说说<code>underscore.js</code>的整体架构，然后再来说说<code>undefined</code>为何被<code>void 0</code>替代，最后再来说说<code>underscore.js</code>中的<code>_.keys</code>函数中的对于<code>for in</code>在IE9以下浏览器中的特殊处理。</p><h2 id="underscore-js的整体架构"><a href="#underscore-js的整体架构" class="headerlink" title="underscore.js的整体架构"></a><code>underscore.js</code>的整体架构</h2><p>&emsp;&emsp;首先<code>underscore.js</code>用一个立即执行函数将所有的代码包裹起来，形成一个独立的作用域，来防止其他代码对于underscore代码的影响，同时避免全局变量的污染。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//     Underscore.js 1.8.3</span></span><br><span class="line"><span class="comment">//     http://underscorejs.org</span></span><br><span class="line"><span class="comment">//     (c) 2009-2017 Jeremy Ashkenas, DocumentCloud and Investigative Reporters &amp; Editors</span></span><br><span class="line"><span class="comment">//     Underscore may be freely distributed under the MIT license.</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//all codes here</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;核心代码的第一部分，就是一些基本的配置。<br>&emsp;&emsp;首先建立root对象，在客户端（浏览器）中建立<code>window</code>(<code>self</code>)，在服务端建立（node环境下）<code>global</code>,或者一些虚拟机中建立<code>this</code>。为了支持<code>webWorker</code>，作者用<code>self</code>代替<code>window</code>进行配置。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> Baseline setup</span><br><span class="line">    基本配置</span><br><span class="line">  <span class="regexp">//</span> --------------</span><br><span class="line"></span><br><span class="line">  <span class="regexp">//</span> Establish the root object, `<span class="javascript"><span class="built_in">window</span></span>` (`<span class="javascript">self</span>`) <span class="keyword">in</span> the browser, `<span class="javascript">global</span>`</span><br><span class="line">  <span class="regexp">//</span> <span class="literal">on</span> the server, <span class="keyword">or</span> `<span class="javascript"><span class="keyword">this</span></span>` <span class="keyword">in</span> some virtual machines. We use `<span class="javascript">self</span>`</span><br><span class="line">  <span class="regexp">//</span> instead <span class="keyword">of</span> `<span class="javascript"><span class="built_in">window</span></span>` <span class="keyword">for</span> `<span class="javascript">WebWorker</span>` support.</span><br><span class="line">  var root = <span class="keyword">typeof</span> self == <span class="string">'object'</span> &amp;&amp; self.self === self &amp;&amp; self ||</span><br><span class="line">            <span class="keyword">typeof</span> <span class="built_in">global</span> == <span class="string">'object'</span> &amp;&amp; <span class="built_in">global</span>.<span class="built_in">global</span> === <span class="built_in">global</span> &amp;&amp; <span class="built_in">global</span> ||</span><br><span class="line">            <span class="keyword">this</span> ||</span><br><span class="line">            &#123;&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;之后将全局环境中的<code>_</code>变量赋值给<code>previousUnderscore</code>,用于后面的<code>noConflict</code>函数来解决冲突.   </p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save the previous value of the `_` variable.</span></span><br><span class="line">  <span class="keyword">var</span> previousUnderscore = root.<span class="literal">_</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 使用noConflict方法返回自身</span></span><br><span class="line">  <span class="literal">_</span>.noConflict = <span class="function"><span class="keyword">function</span></span>() &#123;</span><br><span class="line">    root.<span class="literal">_</span> = previousUnderscore;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来做了一些变量缓存，为的是减少代码压缩的体积，当然这里的代码压缩不是指的的<code>gzip</code>压缩，当然，代码缓存还包含了快速引用，减少js引擎在原型链中查找的长度，提高代码效率。    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save bytes in the minified (but not gzipped) version:</span></span><br><span class="line">  <span class="keyword">var</span> ArrayProto = <span class="built_in">Array</span>.prototype, ObjProto = <span class="built_in">Object</span>.prototype;</span><br><span class="line">  <span class="keyword">var</span> SymbolProto = <span class="keyword">typeof</span> <span class="built_in">Symbol</span> !== <span class="string">'undefined'</span> ? <span class="built_in">Symbol</span>.prototype : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create quick reference variables for speed access to core prototypes.</span></span><br><span class="line">  <span class="keyword">var</span> push = ArrayProto.push,</span><br><span class="line">      slice = ArrayProto.slice,</span><br><span class="line">      toString = ObjProto.toString,</span><br><span class="line">      hasOwnProperty = ObjProto.hasOwnProperty;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下里定义了一些变量去引用<code>ES5</code>中的一些方法，如果环境允许使用，则<code>underscore</code>会优先使用它们。  </p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// All **ECMAScript 5** native function implementations that we hope to use</span></span><br><span class="line">  <span class="comment">// are declared here.</span></span><br><span class="line">  <span class="keyword">var</span> nativeIsArray = <span class="keyword">Array</span>.isArray,</span><br><span class="line">      nativeKeys = <span class="keyword">Object</span>.keys,</span><br><span class="line">      nativeCreate = <span class="keyword">Object</span>.create;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;之后声明一个<code>Ctor</code>变量，用于后面<code>baseCreate</code>函数来兼容老版本 JavaScript 的继承,即用来实现 Object.create 函数。 </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Naked function reference for surrogate-prototype-swapping.</span></span><br><span class="line">  <span class="keyword">var</span> Ctor = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// An internal function for creating a new object that inherits from another.</span></span><br><span class="line">  <span class="keyword">var</span> baseCreate = <span class="function"><span class="keyword">function</span><span class="params">(prototype)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_.isObject(prototype)) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (nativeCreate) <span class="keyword">return</span> nativeCreate(prototype);</span><br><span class="line">    Ctor.prototype = prototype;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> Ctor;</span><br><span class="line">    Ctor.prototype = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来声明<code>_</code>构造函数，函数内部做了一步优化处理,用于检测用户是否使用了<code>new</code>关键字调用，若果没有，则返回一个new实例。    </p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a safe reference to the Underscore object for use below.</span></span><br><span class="line">  <span class="keyword">var</span> <span class="literal">_</span> = <span class="function"><span class="keyword">function</span></span>(obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj instanceof <span class="literal">_</span>) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="built_in">this</span> instanceof <span class="literal">_</span>)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">_</span>(obj);</span><br><span class="line">    <span class="built_in">this</span>._wrapped = obj;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>接下来就是，在node.js环境下将underscore作为一个模块使用，并向后兼容旧版的模块API，即require。如果是浏览器环境下则暴露在全局环境下。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Export the Underscore object for **Node.js**, with</span></span><br><span class="line">  <span class="comment">// backwards-compatibility for their old module API. If we're in</span></span><br><span class="line">  <span class="comment">// the browser, add `_` as a global object.</span></span><br><span class="line">  <span class="comment">// (`nodeType` is checked to ensure that `module`</span></span><br><span class="line">  <span class="comment">// and `exports` are not HTML elements.)</span></span><br><span class="line">  <span class="keyword">if</span> (typeof <span class="keyword">exports</span> != <span class="string">'undefined'</span> &amp;&amp; !<span class="keyword">exports</span>.nodeType) &#123;</span><br><span class="line">    <span class="keyword">if</span> (typeof <span class="keyword">module</span> != <span class="string">'undefined'</span> &amp;&amp; !<span class="keyword">module</span>.nodeType &amp;&amp; <span class="keyword">module</span>.<span class="keyword">exports</span>) &#123;</span><br><span class="line">      <span class="keyword">exports</span> = <span class="keyword">module</span>.<span class="keyword">exports</span> = _;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">exports</span>._ = _;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    root._ = _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Current version.</span></span><br><span class="line">  _.VERSION = <span class="string">'1.8.3'</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;关于<code>underscore</code>的架构先写这么多，之后有坑再来填吧。</p><h2 id="undefined为何被void-0替代"><a href="#undefined为何被void-0替代" class="headerlink" title="undefined为何被void 0替代"></a><code>undefined</code>为何被<code>void 0</code>替代</h2><p>&emsp;&emsp;注意到<code>underscore</code>函数中有一个函数<code>isUndefined</code>是用来判断undefined的，代码如下：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Is a given variable undefined?</span></span><br><span class="line">  _.isUndefined = <span class="function"><span class="keyword">function</span><span class="params">(obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj === <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><p>为什么需要用<code>void 0</code>来代替<code>undefined</code>呢？查阅了相关的资料，最终在<a href="https://github.com/getify/You-Dont-Know-JS/blob/master/types%20%26%20grammar/ch2.md#void-operator" target="_blank" rel="noopener">《You-Dont-Know-JS》</a>中找到答案。<br>&emsp;&emsp;<code>undefined</code>是一个内置的标识符，不过它是可以被赋值的，可以从以下代码中看出来。    </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="literal">undefined</span> = <span class="number">2</span>; <span class="comment">// really bad idea!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="literal">undefined</span> = <span class="number">2</span>; <span class="comment">// TypeError!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在严格模式非严格模式下，我们都可以声明一个名为<code>undefined</code>的局部变量。正是因为如此，<code>underscore</code>才会定义<code>isUndefined</code>来特殊处理<code>undefined</code>。    </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="literal">undefined</span> = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="literal">undefined</span> ); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;表达式<code>void _</code>没有返回值，因此返回值为<code>undefined</code>。同时，<code>void</code>并不会改变表达式的返回值，只是让函数不返回值。按照惯例我们使用<code>void 0</code>来获取<code>undefined</code>（这种习惯来自于C语言）。    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="keyword">void</span> a, a ); <span class="comment">// undefined 42</span></span><br></pre></td></tr></table></figure><h2 id="keys和-allKeys函数"><a href="#keys和-allKeys函数" class="headerlink" title="_.keys和_.allKeys函数"></a><code>_.keys</code>和<code>_.allKeys</code>函数</h2><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Retrieve the names of an object's own properties.</span></span><br><span class="line">     <span class="comment">// Delegates to **ECMAScript 5**'s native `Object.keys`.</span></span><br><span class="line">     <span class="literal">_</span>.keys = <span class="function"><span class="keyword">function</span></span>(obj) &#123;</span><br><span class="line">       <span class="keyword">if</span> (!<span class="literal">_</span>.isObject(obj)) <span class="keyword">return</span> [];</span><br><span class="line">       <span class="keyword">if</span> (nativeKeys) <span class="keyword">return</span> nativeKeys(obj);</span><br><span class="line">       <span class="keyword">var</span> keys = [];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) <span class="keyword">if</span> (<span class="literal">_</span>.has(obj, key)) keys.push(key);</span><br><span class="line">       <span class="comment">// Ahem, IE &lt; 9.</span></span><br><span class="line">       <span class="keyword">if</span> (hasEnumBug) collectNonEnumProps(obj, keys);</span><br><span class="line">       <span class="keyword">return</span> keys;</span><br><span class="line">     &#125;;</span><br><span class="line">   </span><br><span class="line">     <span class="comment">// Retrieve all the property names of an object.</span></span><br><span class="line">     <span class="literal">_</span>.allKeys = <span class="function"><span class="keyword">function</span></span>(obj) &#123;</span><br><span class="line">       <span class="keyword">if</span> (!<span class="literal">_</span>.isObject(obj)) <span class="keyword">return</span> [];</span><br><span class="line">       <span class="keyword">var</span> keys = [];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) keys.push(key);</span><br><span class="line">       <span class="comment">// Ahem, IE &lt; 9.</span></span><br><span class="line">       <span class="keyword">if</span> (hasEnumBug) collectNonEnumProps(obj, keys);</span><br><span class="line">       <span class="keyword">return</span> keys;</span><br><span class="line">     &#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意到<code>_.keys</code>和<code>_.allKeys</code>对于对于IE9 以下的环境做了一个BUG修复。我们就来看下<code>hasEnumBug</code>和<code>collectNonEnumProps</code>函数是怎样实现的。   </p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Keys in IE &lt; 9 that won't be iterated by `for key in ...` and thus missed.</span></span><br><span class="line"> <span class="keyword">var</span> hasEnumBug = !&#123;toString: <span class="type">null</span>&#125;.propertyIsEnumerable(<span class="string">'toString'</span>);</span><br><span class="line"> <span class="keyword">var</span> nonEnumerableProps = [<span class="string">'valueOf'</span>, <span class="string">'isPrototypeOf'</span>, <span class="string">'toString'</span>,</span><br><span class="line">                     <span class="string">'propertyIsEnumerable'</span>, <span class="string">'hasOwnProperty'</span>, <span class="string">'toLocaleString'</span>];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> collectNonEnumProps = <span class="function"><span class="keyword">function</span></span>(obj, keys) &#123;</span><br><span class="line">   <span class="keyword">var</span> nonEnumIdx = nonEnumerableProps.length;</span><br><span class="line">   <span class="keyword">var</span> constructor = obj.constructor;</span><br><span class="line">   <span class="keyword">var</span> proto = <span class="literal">_</span>.isFunction(constructor) &amp;&amp; constructor.prototype || ObjProto;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Constructor is a special case.</span></span><br><span class="line">   <span class="keyword">var</span> prop = <span class="string">'constructor'</span>;</span><br><span class="line">   <span class="keyword">if</span> (<span class="literal">_</span>.has(obj, prop) &amp;&amp; !<span class="literal">_</span>.contains(keys, prop)) keys.push(prop);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (nonEnumIdx--) &#123;</span><br><span class="line">     prop = nonEnumerableProps[nonEnumIdx];</span><br><span class="line">     <span class="keyword">if</span> (prop <span class="keyword">in</span> obj &amp;&amp; obj[prop] !== proto[prop] &amp;&amp; !<span class="literal">_</span>.contains(keys, prop)) &#123;</span><br><span class="line">       keys.push(prop);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;IE &lt; 9下不能用<code>for key in ...</code>来枚举对象的某些 key比如重写了对象的 <code>toString</code> 方法，这个 key 值就不能在 IE &lt; 9 下用 <code>for in</code> 枚举到IE &lt; 9，<code>{toString: null}.propertyIsEnumerable(&#39;toString&#39;)</code>返回 false,所以IE &lt; 9，重写的 <code>toString</code> 属性被认为不可枚举，所以在<code>underscore</code>中定义了<code>hasEnumBug</code>函数利用<code>propertyIsEnumerable</code>方法来判断是否有这个bug。<br>&emsp;&emsp;IE &lt; 9 下不能用 for in 来枚举的 key 值集合有<code>[&#39;valueOf&#39;, &#39;isPrototypeOf&#39;, &#39;toString&#39;, &#39;propertyIsEnumerable&#39;, &#39;hasOwnProperty&#39;, &#39;toLocaleString&#39;]</code>。<br>&emsp;&emsp;proto 变量保存了原型，一个对象的原型可以通过 <code>obj.constructor.prototype</code> 获取，但是如果重写了 <code>constructor</code> 很显然就无法这样获取了，则用 <code>Object.prototype</code> 替换。这样比如说重写了 <code>toString</code>，我们只需要比较 <code>obj.toString</code> 是否和 <code>proto.toString</code>引用相同即可。<br>&emsp;&emsp;至于<code>if (prop in obj &amp;&amp; obj[prop] !== proto[prop] &amp;&amp; !_.contains(keys, prop))</code>中对于<code>prop in obj</code>的判断，我觉得是有必要的，有一种情况如果不加结果就会不同：    </p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var <span class="attr">o</span> = &#123;&#125;</span><br><span class="line">var <span class="attr">keys</span> = []</span><br><span class="line">collectNonEnumProps(o, keys)</span><br><span class="line">// <span class="attr">keys</span> = []</span><br><span class="line"></span><br><span class="line">o.<span class="attr">__proto__</span> = <span class="literal">null</span></span><br><span class="line">// <span class="literal">or</span> Object.setPrototypeOf(o, <span class="literal">null</span>)</span><br><span class="line">collectNonEnumProps(o, keys)</span><br><span class="line">// <span class="attr">keys</span> = [<span class="string">"toLocaleString"</span>, <span class="string">"hasOwnProperty"</span>, <span class="string">"propertyIsEnumerable"</span>, <span class="string">"toString"</span>, <span class="string">"isPrototypeOf"</span>, <span class="string">"valueOf"</span>]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;起始今天有点晕晕的，文章写到这也差不多写完了，后面有时间应该也会来重新看看，如果有错的地方也会自行修改。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;最近开始看一些传统前端框架和库的源码，包括&lt;code&gt;Bootstrap underscore&lt;/code&gt;等，准备在2017年刚步入工作的这半年里面能够有时间阅读完，同时能够将阅读过程中的收获记录下来。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;阅读一些著名框
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://illuSioN4ng.github.io/categories/JavaScript/"/>
    
    
      <category term="underscore.js" scheme="http://illuSioN4ng.github.io/tags/underscore-js/"/>
    
  </entry>
  
  <entry>
    <title>jshint配置文件</title>
    <link href="http://illuSioN4ng.github.io/2017/08/19/jshint/"/>
    <id>http://illuSioN4ng.github.io/2017/08/19/jshint/</id>
    <published>2017-08-19T14:40:26.000Z</published>
    <updated>2018-01-20T09:11:41.669Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;今天学习了下<code>jshint</code>的配置相关，配置如下：<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">//</span> Details: https:<span class="string">//github.com/victorporof/Sublime-JSHint</span><span class="comment">#using-your-own-jshintrc-options</span></span><br><span class="line">  <span class="string">//</span> Example: https:<span class="string">//github.com/jshint/jshint/blob/master/examples/.jshintrc</span></span><br><span class="line">  <span class="string">//</span> Documentation: http:<span class="string">//www.jshint.com/docs/</span></span><br><span class="line">  <span class="string">//</span> Error Explanations: http:<span class="string">//jslinterrors.com/</span></span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>强制性配置<span class="params">---------------------------------------------------------------------------------------</span></span><br><span class="line">  <span class="string">//-------------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>是否为ES5的严格模式</span><br><span class="line">  <span class="string">//</span><span class="params">(reference: http://www.infoq.com/cn/news/2009/12/ecmascript5)</span></span><br><span class="line">  <span class="string">//</span><span class="params">(reference: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode)</span></span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:不为严格模式</span><br><span class="line">  <span class="string">//true</span>:严格模式 必须在文件或function第一行声明 'use strict';</span><br><span class="line">  <span class="string">"strict"</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>禁止使用位操作符如^ | &amp; 等 <span class="params">(例如var <span class="attr">a</span> = b ^ 3会报错)</span></span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:不禁止</span><br><span class="line">  <span class="string">//true</span>: 禁止</span><br><span class="line">  <span class="string">"bitwise"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>是否必须使用驼峰命名法</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:非必须</span><br><span class="line">  <span class="string">//true</span>:必须</span><br><span class="line">  <span class="string">"camelcase"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>强制使用===和!===这样的符号，禁止使用==和!=这样的符号</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:不强制</span><br><span class="line">  <span class="string">//true</span>:强制</span><br><span class="line">  <span class="string">"eqeqeq"</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>代码块必须在&#123;&#125;包围中<span class="params">(例如：if (true)</span> return;会报错，必须用<span class="keyword">if</span> <span class="params">(true)</span> &#123;return;&#125;)</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:非必须</span><br><span class="line">  <span class="string">//true</span>:必须</span><br><span class="line">  <span class="string">"curly"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//for</span> in 循环里强制使用hasOwnProperty</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:不强制</span><br><span class="line">  <span class="string">//true</span>:强制</span><br><span class="line">  <span class="string">//</span><span class="string">"forin"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>函数表达式需要用括号包含起来</span><br><span class="line">  <span class="string">//</span>例如:</span><br><span class="line">  <span class="string">//var</span> result = function <span class="params">()</span> &#123;return &#123;&#125;;&#125; <span class="params">()</span>; ===&gt;不强制</span><br><span class="line">  <span class="string">//var</span> result = <span class="params">(function ()</span> &#123;return &#123;&#125;;&#125; <span class="params">()</span>); ===&gt;强制</span><br><span class="line">  <span class="string">//var</span> result = <span class="params">(function ()</span> &#123;return &#123;&#125;;&#125; )<span class="params">()</span>; ===&gt;强制</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:不强制</span><br><span class="line">  <span class="string">//true</span>:强制</span><br><span class="line">  <span class="string">"immed"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>使用字符串变量时用单引号还是双引号</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:单双引号无所谓</span><br><span class="line">  <span class="string">//true</span>:单双引号都可以，但只能用一种，不能既有单引号又有双引号;</span><br><span class="line">  <span class="string">//</span><span class="string">"sigle"</span>:只能用单引号</span><br><span class="line">  <span class="string">//</span><span class="string">"double"</span>:只能用双引号</span><br><span class="line">  <span class="string">"quotmark"</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>强制类名的第一个字母为大写</span><br><span class="line">  <span class="string">//false</span>:不强制</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">true</span>:强制</span><br><span class="line">  <span class="string">//</span><span class="string">"newcap"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>是否允许空的&#123;&#125;代码块 例如设为<span class="literal">true</span>时，<span class="keyword">if</span> <span class="params">(true)</span> &#123;&#125;会报错</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:允许</span><br><span class="line">  <span class="string">//true</span>:不允许，会报错</span><br><span class="line">  <span class="string">"noempty"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>是否禁止使用arguments.caller和arguments.callee</span><br><span class="line">  <span class="string">//</span>注意：在ES5中这个是禁止的，故设置了ES5模式后，无论这个参数怎么设置，都是不允许callee的</span><br><span class="line">  <span class="string">//false</span>:不禁止</span><br><span class="line">  <span class="string">//true</span>:禁止</span><br><span class="line">  <span class="string">"noarg"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//new</span> Class<span class="params">()</span>;必须赋值给某个变量</span><br><span class="line">  <span class="string">//</span>例如：new Class<span class="params">()</span>错；var a = new Class<span class="params">()</span>对</span><br><span class="line">  <span class="string">//</span>注意：new Class<span class="params">()</span><span class="string">.method</span><span class="params">()</span>是允许的</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:不强制</span><br><span class="line">  <span class="string">//true</span>:强制</span><br><span class="line">  <span class="string">"nonew"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>禁止使用--和++操作符<span class="params">(表示不理解为何这也要禁止)</span></span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:不禁止</span><br><span class="line">  <span class="string">//true</span>:禁止</span><br><span class="line">  <span class="string">//</span><span class="string">"plusplus"</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>代码行后面有多余的空格报错</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:不报错</span><br><span class="line">  <span class="string">//true</span>:报错</span><br><span class="line">  <span class="string">"trailing"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>使用了未定义的变量</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:不报错</span><br><span class="line">  <span class="string">//true</span>: 报错</span><br><span class="line">  <span class="string">"undef"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>声明了变量但没有使用到这个变量</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:不报错</span><br><span class="line">  <span class="string">//true</span>:报错</span><br><span class="line">  <span class="string">"unused"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>函数需要先声明再使用</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:不强制先声明</span><br><span class="line">  <span class="string">//true</span>:强制需要先声明</span><br><span class="line">  <span class="string">"latedef"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>是否为标准语法，是否禁止一些不标注的用法</span><br><span class="line">  <span class="string">//ES3</span>开始反对一些用法，如escape/unescape等，此参数用于设置是否禁止使用escape等</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:禁止使用</span><br><span class="line">  <span class="string">//true</span>:不禁止</span><br><span class="line">  <span class="string">//</span><span class="string">"nonstandard"</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>是否允许扩展javascript内置对象的方法，有些时候这是不被推荐的</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:允许</span><br><span class="line">  <span class="string">//true</span>:禁止扩展</span><br><span class="line">  <span class="string">//</span><span class="string">"freeze"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//TODO</span></span><br><span class="line">  <span class="string">//</span>貌似这个参数已经不推荐设置了</span><br><span class="line">  <span class="string">//</span><span class="string">"nonbsp"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>设置函数的最大参数数量（虽然参数太多是不推荐的，但是不应该强制）</span><br><span class="line">  <span class="string">//</span><span class="string">"maxparams"</span>: 100,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>程序段的嵌套最大深度</span><br><span class="line">  <span class="string">//</span>例如：<span class="keyword">if</span> <span class="params">(true)</span> &#123;while <span class="params">(true)</span> &#123;<span class="keyword">if</span> <span class="params">(true)</span> &#123;doSth<span class="params">()</span>;&#125;&#125;&#125;的嵌套深度是3</span><br><span class="line">  <span class="string">//</span><span class="string">"maxdepth"</span>: 10,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>函数内变量声明的最大数量 如：function test<span class="params">()</span> &#123;var a, b, c, d;&#125;是4</span><br><span class="line">  <span class="string">//</span>注意：function内声明一个function也算一个 如：function a<span class="params">()</span> &#123;function b<span class="params">()</span> &#123;&#125;&#125;是1</span><br><span class="line">  <span class="string">//</span><span class="string">"maxstatements"</span>: 100,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>代码行的最大长度（字符数量）</span><br><span class="line">  <span class="string">//</span><span class="string">"maxlen"</span>: 80,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>代码复杂度</span><br><span class="line">  <span class="string">//</span><span class="string">"maxcomplexity"</span>: 10,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>缩进的长度</span><br><span class="line">  <span class="string">"indent"</span>: 4,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>运行环境配置<span class="params">--------------------------------------------------------------------------------------</span></span><br><span class="line">  <span class="string">//--------------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>是不是为浏览器端javascript,作用是遇到window document navigator这些变量不需要声明</span><br><span class="line">  <span class="string">//</span>注意：alert console这些变量还是会报错</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:遇到window等未声明，则报错</span><br><span class="line">  <span class="string">//true</span>:不报错</span><br><span class="line">  <span class="string">"browser"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>是否为nodejs环境,作用之一是console变量未声明时不报错</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:使用未声明的console时报错</span><br><span class="line">  <span class="string">//true</span>:使用未声明的console时不报错</span><br><span class="line">  <span class="string">"node"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>是否使用了jQuery基础库</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>: 未使用</span><br><span class="line">  <span class="string">//true</span>:使用了未声明的jQuery变量时不报错</span><br><span class="line">  <span class="string">"jquery"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>自定义配置<span class="params">----------------------------------------------------------------------------------------</span></span><br><span class="line">  <span class="string">//--------------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>自定义一些全局变量，使之在未声明时不报错</span><br><span class="line">  <span class="string">"globals"</span>: &#123;</span><br><span class="line">    <span class="string">"$"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"jQuery"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"alert"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"console"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"require"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"angular"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"exports"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"process"</span><span class="function">:false</span>,</span><br><span class="line">    <span class="string">"__dirname"</span><span class="function">:false</span>,</span><br><span class="line">    <span class="string">"define"</span>: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>与globals的的作用大同小异</span><br><span class="line">  <span class="string">"predef"</span>: [</span><br><span class="line">    <span class="string">"module"</span>,</span><br><span class="line">    <span class="string">"require"</span>,</span><br><span class="line">    <span class="string">"__dirname"</span>,</span><br><span class="line">    <span class="string">"process"</span>,</span><br><span class="line">    <span class="string">"console"</span>,</span><br><span class="line">    <span class="string">"it"</span>,</span><br><span class="line">    <span class="string">"describe"</span>,</span><br><span class="line">    <span class="string">"before"</span>,</span><br><span class="line">    <span class="string">"after"</span>,</span><br><span class="line">    <span class="string">"should"</span></span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>非强制性配置<span class="params">------------------------------------------------------------------------------------------</span></span><br><span class="line">  <span class="string">//------------------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>允许全局的<span class="string">"use strict"</span>声明</span><br><span class="line">  <span class="string">//</span>建议：</span><br><span class="line">  <span class="string">//</span>在编辑器的验证中可以设为<span class="literal">true</span></span><br><span class="line">  <span class="string">//</span>但是在验证整个项目文件时设为允许会引起一些第三方插件出问题，所以建议设为<span class="literal">false</span><span class="params">(默认)</span></span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:不允许</span><br><span class="line">  <span class="string">//true</span>: 允许</span><br><span class="line">  <span class="string">"globalstrict"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>容忍句尾不加分号</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:不容忍</span><br><span class="line">  <span class="string">//true</span>:容忍</span><br><span class="line">  <span class="string">//</span><span class="string">"asi"</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>在一些需要条件表达式的地方可否使用赋值语句</span><br><span class="line">  <span class="string">//</span>例如：<span class="keyword">if</span> <span class="params">(<span class="attr">a</span> = b)</span> &#123;doSth<span class="params">()</span>;&#125;</span><br><span class="line">  <span class="string">//</span>例如：for <span class="params">(var <span class="attr">i</span> = 0, person; <span class="attr">person</span> = people[i]; i++)</span> &#123;&#125;</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:不允许</span><br><span class="line">  <span class="string">//true</span>:允许</span><br><span class="line">  <span class="string">"boss"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>允许使用v == null，可结合<span class="string">"eqeqeq"</span>理解</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:不允许</span><br><span class="line">  <span class="string">//true</span>:允许</span><br><span class="line">  <span class="string">"eqnull"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>允许使用eval</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:不允许</span><br><span class="line">  <span class="string">//true</span>:允许</span><br><span class="line">  <span class="string">//</span><span class="string">"evil"</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>是否允许一段表达式作为一段单独的程序</span><br><span class="line">  <span class="string">//</span>这个参数比较有趣</span><br><span class="line">  <span class="string">//</span>例如有这样的程序：<span class="keyword">if</span> <span class="params">(condition)</span> &#123;doSth<span class="params">()</span>;&#125;有人喜欢这样写：condition &amp;&amp; doSth<span class="params">()</span>;</span><br><span class="line">  <span class="string">//</span>然而后者是一段表达式，在js引擎中这不属于语法错误，但是大多数情况下，很多人是不推荐这种用法的</span><br><span class="line">  <span class="string">//</span>个人比较倾向后者用法，故设为<span class="literal">true</span></span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:不允许</span><br><span class="line">  <span class="string">//true</span>:允许</span><br><span class="line">  <span class="string">"expr"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>允许在控制结构里声明变量而在外面使用它</span><br><span class="line">  <span class="string">//</span>例如：<span class="keyword">if</span> <span class="params">(condition)</span> &#123;var test = 'test';&#125; alert<span class="params">(test)</span>;是不报语法错误的，但是这样是极不好的在很多浏览器中甚至不兼容</span><br><span class="line">  <span class="string">//</span>注:上面的类似例子经常在前端职位笔试题中出现</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:不允许</span><br><span class="line">  <span class="string">//true</span>:允许</span><br><span class="line">  <span class="string">//</span><span class="string">"funcscope"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>兼容mozilla特定语法</span><br><span class="line">  <span class="string">//mozilla</span>扩展并重写了一些ES6的语法,例如for each等</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:不支持</span><br><span class="line">  <span class="string">//true</span>:支持</span><br><span class="line">  <span class="string">//</span><span class="string">"moz"</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>允许使用__proto__<span class="params">(只有mozilla中有)</span></span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:不允许</span><br><span class="line">  <span class="string">//true</span>:允许</span><br><span class="line">  <span class="string">//</span><span class="string">"proto"</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//__iterator__</span>属性  目前还没有浏览器支持</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:不支持</span><br><span class="line">  <span class="string">//</span><span class="string">"iterator"</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>单行语句块里的分号可以省略</span><br><span class="line">  <span class="string">//</span>例如：<span class="keyword">if</span> <span class="params">(true)</span> &#123; dosth<span class="params">()</span> &#125; ===&gt; <span class="keyword">if</span> <span class="params">(true)</span> &#123; dosth<span class="params">()</span>; &#125;</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:不可省略</span><br><span class="line">  <span class="string">//true</span>:可省略</span><br><span class="line">  <span class="string">//</span> <span class="string">"lastsemic"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>不安全的断句</span><br><span class="line">  <span class="string">//</span>例如：var a = b + c;有人会把+ c放到第二行,这就属于不安全断句,应该把+留在第一行最后</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:不允许</span><br><span class="line">  <span class="string">//true</span>:允许</span><br><span class="line">  <span class="string">//</span><span class="string">"laxbreak"</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>逗号在前面的代码风格</span><br><span class="line">  <span class="string">//</span>例如：var obj = &#123; a: 'a', b: 'b' &#125;;有人喜欢把a后面的逗号放到第二行的开始</span><br><span class="line">  <span class="string">//</span>这个设置因人而异，这种编程风格也没什么错，个人喜好禁止了这种风格，一般情况下是<span class="literal">true</span></span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:不允许</span><br><span class="line">  <span class="string">//true</span>:允许</span><br><span class="line">  <span class="string">//</span><span class="string">"laxcomma"</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>允许在循环中声明函数  这种方式在很多浏览器中都不是语法错误，但是极不推荐的风格极易引起bug</span><br><span class="line">  <span class="string">//</span>例如：</span><br><span class="line">  <span class="string">//var</span> nums = [];</span><br><span class="line">  <span class="string">//for</span> <span class="params">(var <span class="attr">l</span> = 0; l &lt; 10; l++)</span> &#123;</span><br><span class="line">  <span class="string">//</span>    nums[l] = function <span class="params">(j)</span> &#123;</span><br><span class="line">  <span class="string">//</span>        return i + j;</span><br><span class="line">  <span class="string">//</span>    &#125;;</span><br><span class="line">  <span class="string">//</span>&#125;</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:不允许</span><br><span class="line">  <span class="string">//true</span>:允许</span><br><span class="line">  <span class="string">//</span><span class="string">"loopfunc"</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>是否允许多行形式的字符串  即允许用'\'来划分多行字符串</span><br><span class="line">  <span class="string">//</span>这种用法有点危险，假如'\'后多了一个空格的话会出现意外情况，故推荐设为<span class="literal">false</span>或默认</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:不允许</span><br><span class="line">  <span class="string">//true</span>:允许</span><br><span class="line">  <span class="string">//</span><span class="string">"multistr"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>这个不太好控制,个人倾向于允许</span><br><span class="line">  <span class="string">//</span>允许链接的目标为javascript执行</span><br><span class="line">  <span class="string">//</span>例如：&lt;a href=<span class="string">"javasctip:alert(111);"</span>&gt;&lt;<span class="string">/a</span>&gt;</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:不允许</span><br><span class="line">  <span class="string">//true</span>:允许</span><br><span class="line">  <span class="string">"scripturl"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>允许重复定义同一个变量 如：var x = 9; var x = 10;是错误的</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:不允许</span><br><span class="line">  <span class="string">//true</span>:允许</span><br><span class="line">  <span class="string">//</span><span class="string">"shadow"</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>当可以用obj.p的情况下使用obj['p']这样的方式</span><br><span class="line">  <span class="string">//</span>注：只有obj['p x q']这样的情况才推荐使用[]</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:不允许obj['p']</span><br><span class="line">  <span class="string">//true</span>:允许</span><br><span class="line">  <span class="string">//</span><span class="string">"sub"</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>允许使用var c = new function <span class="params">()</span> &#123;&#125;;和var c = new Class;这样的写法<span class="params">(很多js引擎都支持)</span></span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>：不允许</span><br><span class="line">  <span class="string">//true</span>:允许</span><br><span class="line">  <span class="string">//</span><span class="string">"supernew"</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>允许非类里面使用this</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:不允许</span><br><span class="line">  <span class="string">//true</span>:允许</span><br><span class="line">  <span class="string">//</span><span class="string">"validthis"</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//TODO</span></span><br><span class="line">  <span class="string">//</span>混用tab和空格时是否报错<span class="params">(为了防止tab与空格混用，建议设为false或默认不设置)</span></span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:不可混用</span><br><span class="line">  <span class="string">//true</span>:可混用</span><br><span class="line">  <span class="string">"smarttabs"</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>允许ecmascript5语法，例如：getters/setters</span><br><span class="line">  <span class="string">//TODO</span>个人不明白这个和strict有什么区别，既然有了strict选项还要这个干什么?</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:不允许</span><br><span class="line">  <span class="string">//true</span></span><br><span class="line">  <span class="string">//</span><span class="string">"es5"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>允许ecmascript6语法</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:不允许</span><br><span class="line">  <span class="string">//true</span></span><br><span class="line">  <span class="string">//</span><span class="string">"esnext"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>允许出现debugger语句</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:不允许</span><br><span class="line">  <span class="string">//true</span>:允许</span><br><span class="line">  <span class="string">//</span><span class="string">"debug"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>一些历史遗留的配置<span class="params">-------------------------------------------------------------------------------------</span></span><br><span class="line">  <span class="string">//-------------------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>一个function内只允许一个var</span><br><span class="line">  <span class="string">//</span>注：jshint已不推荐这种用法</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:不强制</span><br><span class="line">  <span class="string">//true</span>:强制</span><br><span class="line">  <span class="string">//</span><span class="string">"onevar"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="string">//</span>严格类型的空白规范（道格拉斯规范）</span><br><span class="line">  <span class="string">//</span>例如:</span><br><span class="line">  <span class="string">//</span>错误：<span class="keyword">if</span><span class="params">(true)</span>&#123;&#125;  正确：<span class="keyword">if</span> <span class="params">(true)</span> &#123;&#125;</span><br><span class="line">  <span class="string">//</span>错误：while<span class="params">(true)</span>&#123;&#125;  正确：while <span class="params">(true)</span> &#123;&#125;</span><br><span class="line">  <span class="string">//</span>错误：while <span class="params">( true )</span> &#123;&#125;  正确：while <span class="params">(true)</span> &#123;&#125;</span><br><span class="line">  <span class="string">//</span><span class="params">(默认)</span><span class="literal">false</span>:非严格</span><br><span class="line">  <span class="string">//true</span>:严格</span><br><span class="line">  <span class="string">"white"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;今天学习了下&lt;code&gt;jshint&lt;/code&gt;的配置相关，配置如下：&lt;br&gt;&lt;figure class=&quot;highlight jboss-cli&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;l
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://illuSioN4ng.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://illuSioN4ng.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>工作首月总结</title>
    <link href="http://illuSioN4ng.github.io/2017/07/30/2017-7/"/>
    <id>http://illuSioN4ng.github.io/2017/07/30/2017-7/</id>
    <published>2017-07-30T12:06:14.000Z</published>
    <updated>2018-01-20T09:11:41.634Z</updated>
    
    <content type="html"><![CDATA[<p>正式入部门一周以来的第一个周末，突然发现博客已经太久太久没有维护了，自从工作确定了之后，一直忙于毕业论文的工作，然后是毕业季，然后是回到合肥搬家、定居，终于所有的一切都稳定下来了，希望以后每周都能稳定的产出一些东西，记录自己的工作、学习、生活。<br>自从七月七日入职讯飞以来，经历了七月十号至七月二十号的展翼行动，收获颇多，有以下几点：</p><ol><li>团队合作。需要充分听取成员的意见，让大家都参与到决策中来，充分发挥大家的能动性，力争选择一个最优的解决思路，去完成工作或者是解决问题。</li><li>个人荣誉。我还是觉得没有必要目的性太强，做好本职的工作，然后重点放在提升自己上，然后才是在团队中发挥额外的作用。</li><li>思辨意识。说话的艺术是我需要去追求的东西，逻辑思维的方式，甚至是吵架的方式，撕逼时候的能力，这些都是我所欠缺的。</li></ol><p>正式进入项目组一周，主要是在看fly.js的文档，发现文档有许多不合适的地方，所以提了几点改进，大概了解了下fly.js的工作流，是在fis的基础上封装了一下，本地服务是基于express，整个项目应该是require.js，大概了解了下以后的工作方式，下周应该会进入新项目，开始一个崭新的世界。<br>还有一个比较重要的东西应该就是内推了，大概看了下，截止今天已经收到了将近70封简历了，下周一统一处理下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;正式入部门一周以来的第一个周末，突然发现博客已经太久太久没有维护了，自从工作确定了之后，一直忙于毕业论文的工作，然后是毕业季，然后是回到合肥搬家、定居，终于所有的一切都稳定下来了，希望以后每周都能稳定的产出一些东西，记录自己的工作、学习、生活。&lt;br&gt;自从七月七日入职讯飞以
      
    
    </summary>
    
      <category term="随笔" scheme="http://illuSioN4ng.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="总结" scheme="http://illuSioN4ng.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="随笔" scheme="http://illuSioN4ng.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>回顾我的2016，展望我的2017</title>
    <link href="http://illuSioN4ng.github.io/2017/01/01/%E5%9B%9E%E9%A1%BE%E6%88%91%E7%9A%842016%EF%BC%8C%E5%B1%95%E6%9C%9B%E6%88%91%E7%9A%842017/"/>
    <id>http://illuSioN4ng.github.io/2017/01/01/回顾我的2016，展望我的2017/</id>
    <published>2017-01-01T15:31:29.000Z</published>
    <updated>2018-01-20T09:11:41.672Z</updated>
    
    <content type="html"><![CDATA[<p>今天是17年元旦，简单给去年做个人总结吧。</p><h2 id="16年初的时候的计划"><a href="#16年初的时候的计划" class="headerlink" title="16年初的时候的计划"></a>16年初的时候的计划</h2><ol><li>顺利拿到实习offer（估计要去得和老板撕逼）；<strong>去京东作为前端实习生</strong></li><li>泸沽湖去一次，不去实习的话估计三四月哥们会过来；<strong>没有去成，猴年也没有去峨眉山，蛮遗憾的</strong></li><li>去帝都见见世面，见一次大海，见一见在北方那些可爱的人们；<strong>借着360前端星的机会去了北京，没有见到海，也没有见到想见的人们</strong></li><li>继续运动，目标135，八块腹肌；<strong>15年冬天膝盖受伤之后一直没有跑步，运动的量也减少了，好在坚持篮球，也开始健身了</strong></li><li>继续坚持读书的习惯，读一些让自己轻松的书；<strong><a href="https://book.douban.com/people/illuSioN4ng/collect" target="_blank" rel="noopener">书单</a>  <a href="https://movie.douban.com/people/illuSioN4ng/collect" target="_blank" rel="noopener">电影清单</a></strong></li><li>不脱单，因为不可能所有的都实现，做人不能贪心，对吧？<strong>failed</strong></li></ol><hr><p>&emsp;&emsp;研二步入研三，找实习找工作必然是重中之重，所以在三月份到五月初那段时间基本上就一直在找实习中度过，其中经历了许许多多让人难忘的事儿，好在最终找到了京东的实习，实习这段时间可能是我成长最快的阶段，感谢我的导师和leader对我的帮助吧，最终找工作还是选择了回家，可能不是最好的选择，但是我不会为这个选择后悔吧，唯一的一点遗憾可能是拒了腾讯的offer。<br>&emsp;&emsp;实习与找工作期间一直在维护自己的博客，不过感觉现在在github page上的博客性能越来越差，17年可能直接在segmentfault上来开始写写文章做做总结了，这个习惯应该会一直坚持的。<br><img src="https://sfault-image.b0.upaiyun.com/983/771/983771179-58689729bbe84_articlex" alt="github提交"><br>&emsp;&emsp;<code>420 contributions in 2016</code>坦白来说，自己的github可能当做自己的代码仓库和博客管理比较多，对于开源的贡献微乎其微，但是对于这个数字我还是比较满意的，不管是学习还是总结，希望以后能够更加有效的利用github，自己也参与到开源中去。</p><hr><h2 id="关于2017"><a href="#关于2017" class="headerlink" title="关于2017"></a>关于2017</h2><ol><li>顺利毕业；</li><li>继续坚持锻炼，体重控制到140；</li><li>坚持读书，坚持在豆瓣上记录自己的阅读以及观影列表；（10本技术类，20本非技术类的书籍）</li><li>七月份入职之后，能够胜任自己的工作，爱岗敬业吧；</li><li>毕业之后，搬进新家，布置自己的书房，好好生活，带着妈妈旅游两次；</li><li>学习计划的话，可能视情况而定吧，初步是将16年很多想要了解的东西都在毕业前熟悉一下；</li><li>如果可以的话，工作后，希望能给自己买个单反，记录生活的美好。</li><li>对于感情，不奢求了Orz~~~~</li></ol><hr><p>暂且先写这么多，2017 to be continued!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天是17年元旦，简单给去年做个人总结吧。&lt;/p&gt;
&lt;h2 id=&quot;16年初的时候的计划&quot;&gt;&lt;a href=&quot;#16年初的时候的计划&quot; class=&quot;headerlink&quot; title=&quot;16年初的时候的计划&quot;&gt;&lt;/a&gt;16年初的时候的计划&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;顺利拿
      
    
    </summary>
    
      <category term="年终总结" scheme="http://illuSioN4ng.github.io/categories/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="2016总结 &amp;&amp; 2017展望" scheme="http://illuSioN4ng.github.io/tags/2016%E6%80%BB%E7%BB%93-2017%E5%B1%95%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>学习日记</title>
    <link href="http://illuSioN4ng.github.io/2017/01/01/%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
    <id>http://illuSioN4ng.github.io/2017/01/01/学习日记/</id>
    <published>2017-01-01T07:50:30.000Z</published>
    <updated>2018-01-20T09:11:41.673Z</updated>
    
    <content type="html"><![CDATA[<p><strong>这篇文章用来记录自己的学习情况:-)</strong></p><h1 id="2016-11"><a href="#2016-11" class="headerlink" title="2016.11"></a>2016.11</h1><ol><li><strong>《锋利的jquery》读完</strong>    </li><li><strong>《javascript面向对象精要》读完</strong></li><li><strong>《精通css高级web标准解决方案》读完</strong></li><li><strong>《单页web应用》粗读</strong></li><li><strong>《JavaScript面向对象精要》读书笔记完成，共四篇</strong></li><li><strong>读完《活着》</strong> 11.25</li><li><strong>读完《1973年的弹子球》</strong> 11.14</li><li><strong>读《北京折叠》</strong> 11.06</li></ol><h2 id="11-17"><a href="#11-17" class="headerlink" title="11.17"></a>11.17</h2><ol><li>《精通css高级web标准解决方案》读完</li><li><a href="http://illuSioN4ng.github.io/2016/11/17/JavaScript-OOP-2/">完成一篇读书笔记(【JavaScript面向对象精要】（2）-函数)</a></li><li>《单页Web应用》第三章 开发shell读完</li></ol><h2 id="11-24"><a href="#11-24" class="headerlink" title="11.24"></a>11.24</h2><ol><li>开始读《活着》</li><li>《JavaScript设计模式》- 3-4章</li></ol><h1 id="2016-9-2016-10"><a href="#2016-9-2016-10" class="headerlink" title="2016.9 - 2016.10"></a>2016.9 - 2016.10</h1><p><strong>找工作的两个月，学习就放下了，接下来需要继续努力学习，有很多自己不足的地方需要去接触</strong></p><h1 id="2016-8"><a href="#2016-8" class="headerlink" title="2016.8"></a>2016.8</h1><p><strong>八月份最主要还是支持了数据中心二期的项目，提升特别大，主要是了解了Seajs和echarts，模块化编程和数据可视化相关</strong><br><strong>JSHOP，cxman端的用户数据监控相关的需求</strong></p><h1 id="2016-7"><a href="#2016-7" class="headerlink" title="2016.7"></a>2016.7</h1><p><strong>15号CRM店铺会员基本联调完成，之后会是数据中心二期的需求</strong></p><h2 id="3号"><a href="#3号" class="headerlink" title="3号"></a>3号</h2><p><strong>本来准备梳理一下绩效系统的相关东西，但是好像在公司没有把hexo都上传到github上，只能延期了，今天开始看看echarts吧</strong>   </p><ol><li>看了一点点echarts 3的文档</li><li><a href="http://stackoverflow.com/questions/1724255/why-does-2-2-in-javascript" target="_blank" rel="noopener">stackoverflow上面一个关于js’==’的很有意思的问题：Why does 2 == [2] in JavaScript?</a></li><li><a href="illuSioN4ng.github.io/2016/07/03/学习日记/">整理了下http get和post相关知识</a></li><li><a href="http://famanoder.com/bokes/5728b3edad300264162d440a" target="_blank" rel="noopener">关于跨域GET、POST请求的小结</a> <strong>还是有些疑惑的</strong></li></ol><h2 id="10号"><a href="#10号" class="headerlink" title="10号"></a>10号</h2><ol><li><a href="http://caibaojian.com/toutiao/5906" target="_blank" rel="noopener">13个Chrome基础使用技巧</a>    </li><li><a href="http://www.w3cplus.com/javascript/comparing-type-checks-in-JavaScript.html" target="_blank" rel="noopener">JavaScrit的变量：如何检测变量类型</a> 50%</li></ol><h2 id="11号"><a href="#11号" class="headerlink" title="11号"></a>11号</h2><ol><li><a href="https://segmentfault.com/a/1190000005921341" target="_blank" rel="noopener">数组reduce方法的高级技巧</a>     </li><li><a href="http://www.w3cplus.com/javascript/comparing-type-checks-in-JavaScript.html" target="_blank" rel="noopener">JavaScrit的变量：如何检测变量类型</a> 100%    </li><li><a href="http://caibaojian.com/toutiao/5662" target="_blank" rel="noopener">一些你可能不知道JavaScript细节</a>    </li><li>京东前端分享（web性能优化+单元测试）</li><li><a href="http://www.cnblogs.com/coco1s/p/4375774.html" target="_blank" rel="noopener">玩转图片Base64编码</a> <a href="http://tool.oschina.net/encrypt" target="_blank" rel="noopener">在线转换工具</a></li></ol><h2 id="12号"><a href="#12号" class="headerlink" title="12号"></a>12号</h2><p>1.<a href="http://www.jackpu.com/-pian-fei-chang-bu-cuo-de-qian-duan-mian-shi-wen-zhang/" target="_blank" rel="noopener">一篇非常不错的前端面试文章</a></p><h2 id="16号-17号"><a href="#16号-17号" class="headerlink" title="16号 ~ 17号"></a>16号 ~ 17号</h2><ol><li><a href="http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651551029&amp;idx=1&amp;sn=e13bba196039d518118ccda3884073c3&amp;scene=23&amp;srcid=0717rUrX7gWg6XoV62mmJaoR#rd" target="_blank" rel="noopener">浅谈浏览器http的缓存机制</a></li><li><a href="https://github.com/dreamapplehappy/hacking-with-javascript/blob/master/translate/everything-you-wanted-to-know-about-javascript-scope.md" target="_blank" rel="noopener">你想知道的关于JavaScript作用域的一切</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzAwNDcyNjI3OA==&amp;mid=2650839095&amp;idx=1&amp;sn=7cb174a69b110323969529619d8f09f6&amp;scene=23&amp;srcid=0717kPDpPtHLYWLsalB6olr5#rd" target="_blank" rel="noopener">全面理解HTTP</a></li></ol><h1 id="20号"><a href="#20号" class="headerlink" title="20号"></a>20号</h1><ol><li><a href="http://www.alloyteam.com/2016/05/date-object/" target="_blank" rel="noopener">Date对象的那些事儿</a>    </li><li>整理kpi相关 40%</li></ol><h1 id="2016-6"><a href="#2016-6" class="headerlink" title="2016.6"></a>2016.6</h1><p><strong>六月主要是进行JSHOP绩效系统的前后端联调工作，bug修复，初定六月十三号提测</strong><br><strong>JSHOP正式28号上线，估计以后还是会持续维护迭代开发</strong><br><strong>后续会有一个店铺装修的项目是我来接手，还有数据中心相关的东西都是我来接手了，加油</strong>    </p><h2 id="10号-11号"><a href="#10号-11号" class="headerlink" title="10号~11号"></a>10号~11号</h2><ol><li><a href="http://www.zcfy.cc/article/439" target="_blank" rel="noopener">使用CSS完成元素居中的七种方法</a></li><li><a href="http://www.zcfy.cc/article/239#h4-table-of-contents-in-alphabetical-order-link" target="_blank" rel="noopener">CSS伪类与伪元素完全指南</a></li><li><a href="http://www.zcfy.cc/article/416" target="_blank" rel="noopener">设计师/后端工程师也能马上实践！前端设计（CSS设计）的技巧</a></li><li><a href="http://www.zcfy.cc/article/406" target="_blank" rel="noopener">5行JavaScript代码实现页面平滑滚动</a></li></ol><h2 id="6-12"><a href="#6-12" class="headerlink" title="6.12"></a>6.12</h2><ol><li>【绩效系统】-整体联调</li><li>【绩效系统】-考核规则删除编辑模块构建</li></ol><h2 id="6-13"><a href="#6-13" class="headerlink" title="6.13"></a>6.13</h2><ol><li>618值班</li><li>【绩效系统】-测试用例评审</li><li>【绩效系统】-前端优化</li></ol><h2 id="6-14"><a href="#6-14" class="headerlink" title="6.14"></a>6.14</h2><ol><li>【绩效系统】-bug修复 </li><li>【绩效系统】-登陆打分指令+修改打分指令构建联调 </li></ol><h2 id="6-15"><a href="#6-15" class="headerlink" title="6.15"></a>6.15</h2><ol><li>【绩效系统】- 前端文案排查</li><li>【绩效系统】- 修改打分指令弹窗优化</li></ol><h2 id="6-16"><a href="#6-16" class="headerlink" title="6.16"></a>6.16</h2><ol><li>【绩效系统】- 登陆打分指令优化</li><li>【绩效系统】- 修改打分指令优化</li><li>【绩效系统】- 配合测试，bug修复</li></ol><h2 id="6-17"><a href="#6-17" class="headerlink" title="6.17"></a>6.17</h2><ol><li>【绩效系统】- 问题排查+bug修复</li><li>618高潮期线上活动支持 </li></ol><h2 id="6-18"><a href="#6-18" class="headerlink" title="6.18"></a>6.18</h2><ol><li>618高潮期线上活动支持</li><li>【绩效系统】-图片上传改为H5上传</li></ol><h2 id="6-20"><a href="#6-20" class="headerlink" title="6.20"></a>6.20</h2><ol><li>值班+618高潮期线上活动支持</li><li>【绩效系统】-提测+bug修复</li></ol><h2 id="6-21"><a href="#6-21" class="headerlink" title="6.21"></a>6.21</h2><ol><li>【绩效系统】还原度对比</li></ol><h2 id="6-22"><a href="#6-22" class="headerlink" title="6.22"></a>6.22</h2><ol><li>【绩效系统】- 还原度修复</li></ol><h2 id="6-23"><a href="#6-23" class="headerlink" title="6.23"></a>6.23</h2><ol><li>【绩效系统】- 还原度修复</li><li>【绩效系统】- 上线前问题排查</li><li><strong>上线加班至凌晨</strong></li></ol><h2 id="28号"><a href="#28号" class="headerlink" title="28号"></a>28号</h2><ol><li><a href="http://www.zhangxinxu.com/wordpress/2016/02/html-textarea-rows-height/" target="_blank" rel="noopener">HTML textarea cols,rows属性和宽度高度关系研究</a></li></ol><h1 id="2016-5"><a href="#2016-5" class="headerlink" title="2016.5"></a>2016.5</h1><h2 id="2号"><a href="#2号" class="headerlink" title="2号"></a>2号</h2><ol><li>回到成都，继续加油！</li><li>打字练习：时间：11分4秒 速度：56 KMP 正确率：90.68 % 进度：100 %（上次：时间：14分38秒 速度：43 KMP 正确率：89.24 % 进度：100 %）</li></ol><h2 id="3号-1"><a href="#3号-1" class="headerlink" title="3号"></a>3号</h2><ol><li>练字</li><li>整理360Star前端HTTP性能优化相关</li></ol><h2 id="4号"><a href="#4号" class="headerlink" title="4号"></a>4号</h2><p>入职京东</p><p><strong>五月主要是进行JSHOP绩效系统的前端开发以及前后端联调工作</strong></p><h1 id="2016-4"><a href="#2016-4" class="headerlink" title="2016.4"></a>2016.4</h1><h2 id="1号-2号"><a href="#1号-2号" class="headerlink" title="1号~2号"></a>1号~2号</h2><ol><li>leetcode 2.Add Two Numbers</li><li>练字</li><li>调整状态</li></ol><h2 id="5号"><a href="#5号" class="headerlink" title="5号"></a>5号</h2><ol><li><a href="http://illuSioN4ng.github.io/2016/04/05/CSS-cssSkills/">CSS 12 个高级方法</a></li><li>JavaScript高级程序设计 表单脚本+html5脚本编程</li><li>练字</li><li>数据结构 树</li></ol><h2 id="6号"><a href="#6号" class="headerlink" title="6号"></a>6号</h2><ol><li>JavaScript高级程序设计 JSON</li><li>练字</li><li>《三体3-死神永生》45%</li><li>360Star 万年历基本功能实现</li></ol><h2 id="7号-15号"><a href="#7号-15号" class="headerlink" title="7号~15号"></a>7号~15号</h2><p>七号收到360前端星计划的任务通知，开始着手做，提交日期15号</p><h2 id="16号-19号"><a href="#16号-19号" class="headerlink" title="16号~19号"></a>16号~19号</h2><p>京东面试内推+腾讯面试</p><h2 id="21号"><a href="#21号" class="headerlink" title="21号"></a>21号</h2><p>到达帝都、初见360</p><h2 id="22-27号-前端星计划"><a href="#22-27号-前端星计划" class="headerlink" title="22~27号 前端星计划"></a>22~27号 前端星计划</h2><h1 id="2016-3"><a href="#2016-3" class="headerlink" title="2016.3"></a>2016.3</h1><h2 id="1号"><a href="#1号" class="headerlink" title="1号"></a>1号</h2><p> 腾讯实习生面试。</p><h2 id="2号-1"><a href="#2号-1" class="headerlink" title="2号"></a>2号</h2><ol><li>整理腾讯面试题</li></ol><h2 id="3号-2"><a href="#3号-2" class="headerlink" title="3号"></a>3号</h2><ol><li>盲打练习：时间：14分38秒 速度：43 KMP 正确率：89.24 % 进度：100 %</li><li>练字</li><li><a href="http://caibaojian.com/toutiao/5450?wb" target="_blank" rel="noopener">奇葩的JavaScript闭包面试题</a></li><li><a href="http://blogread.cn/it/article/7670?f=wb" target="_blank" rel="noopener">jQuery对象和DOM对象小结</a></li><li><a href="https://yq.aliyun.com/articles/5843#" target="_blank" rel="noopener">《走进git时代系列一》 你该怎么玩？</a></li></ol><h2 id="4号-1"><a href="#4号-1" class="headerlink" title="4号"></a>4号</h2><ol><li>字母键位<br>过关条件：速度达到 30 字/分，正确率达到 95 %<br>你的打字成绩是：每分钟 35 字/分，正确率 100 %</li><li>练字</li><li><a href="http://www.imooc.com/learn/133" target="_blank" rel="noopener">炫丽的倒计时效果Canvas绘图与动画基础</a><br> Canvas绘制基础、倒计时电子钟的实现</li><li><a href="http://blogread.cn/it/article/7798?f=wb" target="_blank" rel="noopener">小谈inline-block的那点空隙</a></li><li>数字盲打练习：失败。。。<br>过关条件：速度达到 30 字/分，正确率达到 95 %<br>你的打字成绩是：每分钟 28 字/分，正确率 100 %</li></ol><h2 id="5号-1"><a href="#5号-1" class="headerlink" title="5号"></a>5号</h2><ol><li>数字盲打练习：<br>  过关条件：速度达到 30 字/分，正确率达到 95 %<br>  你的打字成绩是：每分钟 36 字/分，正确率 99 %</li><li><a href="http://www.imooc.com/learn/133" target="_blank" rel="noopener">炫丽的倒计时效果Canvas绘图与动画基础</a><br> 炫丽的动画效果、优化、扩展、变成绚丽的时钟</li><li>字符盲打练习：失败</li></ol><h2 id="6号-1"><a href="#6号-1" class="headerlink" title="6号"></a>6号</h2><ol><li>《三体2黑暗森林》41%</li><li>练字</li><li><a href="https://github.com/amfe/article/issues/5" target="_blank" rel="noopener">写给前端面试者（大漠，淘宝）</a></li><li><a href="https://github.com/wintercn/blog/issues/4" target="_blank" rel="noopener">谈谈面试与面试题、谈谈面试与面试题 II （winter，淘宝）</a></li></ol><h2 id="7号"><a href="#7号" class="headerlink" title="7号"></a>7号</h2><ol><li><a href="https://segmentfault.com/a/1190000000465431#articleHeader1" target="_blank" rel="noopener">前端开发面试题</a> html篇总结</li><li>阿里电话面试</li><li><a href="http://illuSioN4ng.github.io/2016/03/07/%E9%98%BF%E9%87%8C%E7%94%B5%E8%AF%9D%E4%B8%80%E9%9D%A2%E6%80%BB%E7%BB%93/">总结阿里电话面试</a></li></ol><h2 id="8号"><a href="#8号" class="headerlink" title="8号"></a>8号</h2><ol><li><a href="http://bonsaiden.github.io/JavaScript-Garden/zh/" target="_blank" rel="noopener">JavaScript秘密花园</a> 对象、函数</li><li><a href="http://illuSioN4ng.github.io/2016/03/07/%E9%98%BF%E9%87%8C%E7%94%B5%E8%AF%9D%E4%B8%80%E9%9D%A2%E6%80%BB%E7%BB%93/">温习阿里一面的相关问题</a></li><li><a href="http://ask.todgo.com/detail/7673421914ad.html" target="_blank" rel="noopener">用2个玻璃球找到从一100层的大楼的某一层落下刚好会摔碎，如何制定最优策略</a></li><li><a href="http://blog.csdn.net/ych_ding/article/details/6792389" target="_blank" rel="noopener">统计一个无序数组中出现次数最多的元素</a></li><li><a href="http://cv.qiaobutang.com/post/55b1d3d10cf2d59ed8007963" target="_blank" rel="noopener">腾讯2015年实习生招聘前端开发面试分享</a></li><li><a href="http://cv.qiaobutang.com/post/55b1d6a10cf2d59ed800835c" target="_blank" rel="noopener">腾讯2015年实习生Web前端岗面试经历</a></li></ol><h2 id="9号"><a href="#9号" class="headerlink" title="9号"></a>9号</h2><ol><li><a href="https://segmentfault.com/a/1190000000465431#articleHeader1" target="_blank" rel="noopener">前端开发面试题</a></li><li><a href="http://cv.qiaobutang.com/post/55b329510cf2802e248299b7" target="_blank" rel="noopener">2015腾讯校招WEB前端开发三轮面试经历及面试题分享</a></li><li><a href="https://segmentfault.com/q/1010000000211442" target="_blank" rel="noopener">有道前端面试题：两个很大数如何做加法运算？</a></li><li><a href="http://sj719045032.github.io/2016/03/08/ali-interview/" target="_blank" rel="noopener">石进阿里面经</a></li><li><a href="http://cv.qiaobutang.com/post/55b1eea50cf2d59ed800de95" target="_blank" rel="noopener">2016届腾讯前端实习生招聘面试</a></li><li><a href="http://cv.qiaobutang.com/post/55b1d8bb0cf2d59ed8008be9" target="_blank" rel="noopener">2015腾讯实习招聘前端面试经验分享</a></li></ol><h2 id="10号-1"><a href="#10号-1" class="headerlink" title="10号"></a>10号</h2><ol><li>《三体2黑暗森林》52%</li><li>JS高级程序设计 面向对象</li><li>更新illuSioN4ngMaiTian</li></ol><h2 id="11号-1"><a href="#11号-1" class="headerlink" title="11号"></a>11号</h2><ol><li>面试知识学习</li><li>js数据结构</li><li>程序员面试宝典逻辑题</li><li>《三体2黑暗森林》55%</li></ol><h2 id="12号-1"><a href="#12号-1" class="headerlink" title="12号"></a>12号</h2><ol><li>面试知识学习</li><li>《三体2黑暗森林》100%</li></ol><h2 id="13号"><a href="#13号" class="headerlink" title="13号"></a>13号</h2><ol><li>JS高级程序设计 函数</li><li>面试知识学习</li></ol><h2 id="14号"><a href="#14号" class="headerlink" title="14号"></a>14号</h2><ol><li>CSS水平垂直视觉格式化</li><li>温习github面试相关</li><li>js数据结构 栈，队列，链表</li><li><a href="http://caibaojian.com/477.html?wb" target="_blank" rel="noopener">cookie和session区别</a></li><li><a href="http://web.jobbole.com/83642/" target="_blank" rel="noopener">深入浅出妙用 Javascript 中 apply、call、bind</a></li></ol><h2 id="15号"><a href="#15号" class="headerlink" title="15号"></a>15号</h2><ol><li>gulp/webpack相关了解</li><li>js数据结构了解</li><li>大话数据结构 算法空间复杂度时间复杂度</li><li>温习面试题笔记</li><li>js数据结构 排序算法</li><li>大话数据结构 搜索排序</li><li>学姐资料温习</li><li>原型继承闭包相关</li></ol><h2 id="16号"><a href="#16号" class="headerlink" title="16号"></a>16号</h2><ol><li><strong>腾讯云平台总监面（二面）</strong>发挥一般，有点惨</li></ol><h2 id="18号"><a href="#18号" class="headerlink" title="18号"></a>18号</h2><ol><li>腾讯云平台总监面（二面）总结</li></ol><h2 id="19号"><a href="#19号" class="headerlink" title="19号"></a>19号</h2><ol><li>练字</li><li>百度前端学院开始task1.1、1.2</li><li>JavaScript高级程序设计 BOM</li></ol><h2 id="20号-1"><a href="#20号-1" class="headerlink" title="20号"></a>20号</h2><ol><li>练字</li><li>百度前端学院开始task1.3、1.4</li><li>《三体3死神永生》10%</li></ol><h2 id="21号-1"><a href="#21号-1" class="headerlink" title="21号"></a>21号</h2><ol><li>腾讯云平台通知被枪毙了，心疼<del>~~(&gt;_&lt;)</del>~~</li><li>练字</li><li>JavaScript秘密花园 函数、数组、类型、核心、其他</li><li>TCP/IP DNS</li><li>牛客网刷JS题20道</li><li>《挪威的森林》 10%</li></ol><h2 id="22号"><a href="#22号" class="headerlink" title="22号"></a>22号</h2><ol><li>《挪威的森林》 30%</li><li>牛客网在线编程 6</li><li>JavaScript高级程序设计  客户端检测</li><li>百度IFE task 1.5</li><li>练字</li></ol><h2 id="23号"><a href="#23号" class="headerlink" title="23号"></a>23号</h2><ol><li>复习笔记本</li><li>看看面试题</li><li>练字</li><li>《挪威的森林》 40%</li></ol><h2 id="24号"><a href="#24号" class="headerlink" title="24号"></a>24号</h2><ol><li>JavaScript高级程序设计 DOM</li><li>《挪威的森林》 60%</li><li>JavaScript语言精粹 继承、语法、对象</li><li>CSS权威指南 颜色和背景</li><li>IFE task 1.12</li></ol><h2 id="26号"><a href="#26号" class="headerlink" title="26号"></a>26号</h2><ol><li>《挪威的森林》100%</li><li>TCP/IP协议族 HTTP</li></ol><h2 id="27号"><a href="#27号" class="headerlink" title="27号"></a>27号</h2><ol><li>百度IFE task10（HTML+CSS告一段落）</li><li>Javascript高级程序设计 事件</li><li>练字</li></ol><h2 id="29号"><a href="#29号" class="headerlink" title="29号"></a>29号</h2><ol><li>Javascript语言精粹 数组+函数</li></ol><h2 id="30号"><a href="#30号" class="headerlink" title="30号"></a>30号</h2><ol><li>Javascript高级程序设计 表单脚本</li><li>Javascript语言精粹 表单脚本</li><li>牛客网刷题 10*2 60%+80%</li><li>百度IFE merge + task 13</li><li>练字</li></ol><h2 id="31号"><a href="#31号" class="headerlink" title="31号"></a>31号</h2><ol><li>牛客网刷提 20*1 80%</li><li>leetcode 1.twoSum + 3.Longest Substring without repeating characters</li><li>练字</li></ol><h1 id="2016-2"><a href="#2016-2" class="headerlink" title="2016.2"></a>2016.2</h1><h2 id="24日（寒假回校第一天）"><a href="#24日（寒假回校第一天）" class="headerlink" title="24日（寒假回校第一天）"></a>24日（寒假回校第一天）</h2><ol><li>《CSS权威指南》-第七章基本视觉格式化</li><li>纯CSS3实现光芒旋转四射的头像动画</li><li>练字</li></ol><h2 id="25日"><a href="#25日" class="headerlink" title="25日"></a>25日</h2><ol><li>纯CSS3实现光芒旋转四射的头像动画代码上传github</li><li>练字</li><li>《CSS权威指南》-第八章 内边距、边框和外边距</li><li>盲打练习：时间：22分4秒 速度：29 KMP 正确率：87.71 % 进度：100 %</li><li><a href="http://www.cnblogs.com/myyouthlife/p/5179731.html" target="_blank" rel="noopener">关于JavaScript 作用域你想知道的一切(博客园)</a></li></ol><h2 id="26日"><a href="#26日" class="headerlink" title="26日"></a>26日</h2><ol><li>盲打练习：时间：15分20秒 速度：41 KMP 正确率：88.82 % 进度：100 %</li><li>了解github项目主页</li><li><a href="http://www.html5dw.com/post?id=1364" target="_blank" rel="noopener">一道常被人轻视的前端JS面试题</a></li></ol><h2 id="28号-1"><a href="#28号-1" class="headerlink" title="28号"></a>28号</h2><ol><li>春熙路证件照</li><li>JS高级程序设计 变量、作用域</li></ol><h2 id="29号-1"><a href="#29号-1" class="headerlink" title="29号"></a>29号</h2><p> 准备腾讯实习生面试，狂刷面试题</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;这篇文章用来记录自己的学习情况:-)&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;2016-11&quot;&gt;&lt;a href=&quot;#2016-11&quot; class=&quot;headerlink&quot; title=&quot;2016.11&quot;&gt;&lt;/a&gt;2016.11&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;
      
    
    </summary>
    
      <category term="Learning Notes" scheme="http://illuSioN4ng.github.io/categories/Learning-Notes/"/>
    
    
      <category term="Learning Notes" scheme="http://illuSioN4ng.github.io/tags/Learning-Notes/"/>
    
  </entry>
  
  <entry>
    <title>从一行CSS调试代码中学到的JavaScript知识</title>
    <link href="http://illuSioN4ng.github.io/2016/11/30/%E4%B8%80%E6%AE%B5css%E8%B0%83%E8%AF%95%E4%BB%A3%E7%A0%81/"/>
    <id>http://illuSioN4ng.github.io/2016/11/30/一段css调试代码/</id>
    <published>2016-11-30T08:25:29.000Z</published>
    <updated>2018-01-20T09:11:41.672Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;话不多说，直接上代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[].forEach.call($$(<span class="string">"*"</span>),<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  a.style.outline=<span class="string">"1px solid #"</span>+(~~(<span class="built_in">Math</span>.random()*(<span class="number">1</span>&lt;&lt;<span class="number">24</span>))).toString(<span class="number">16</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;&emsp;&emsp;话不多说，直接上代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[].forEach.call($$(<span class="string">"*"</span>),<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    a.style.outline=<span class="string">"1px solid #"</span>+(~~(<span class="built_in">Math</span>.random()*(<span class="number">1</span>&lt;&lt;<span class="number">24</span>))).toString(<span class="number">16</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<code>$$(&#39;*&#39;)</code>等价于<code>document.querySelectorAll(&#39;*&#39;)</code>。<a href="http://ourjs.com/detail/54ab768a5695544119000007" target="_blank" rel="noopener">JavaScript中的$$(*)代表什么和$选择器的由来</a><br>&emsp;&emsp;<code>1&lt;&lt;24</code>返回的是16777216（2^24）,所以<code>Math.random()*(1&lt;&lt;24)</code>可以得到一个0 到 16777216之间的值;<code>~</code>操作符（按位取反操作）,通过两次取返就可以得到纯整数部，我们还可以将<code>~~</code>视为<code>parseInt</code>的简写，所以<code>~~(Math.random()*(1&lt;&lt;24))</code>返回的是一个整数。最后颜色就是<code>#000000~#FFFFFF</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;话不多说，直接上代码：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span c
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://illuSioN4ng.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://illuSioN4ng.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>【JavaScript面向对象精要】（4）- 构造函数和原型对象</title>
    <link href="http://illuSioN4ng.github.io/2016/11/30/JavaScript-OOP-4/"/>
    <id>http://illuSioN4ng.github.io/2016/11/30/JavaScript-OOP-4/</id>
    <published>2016-11-30T07:34:32.000Z</published>
    <updated>2018-01-20T09:11:41.660Z</updated>
    
    <content type="html"><![CDATA[<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>&emsp;&emsp;构造函数就是你用new创建对象时调用的函数。例如<code>Obeject</code>、<code>Function</code>、<code>Array</code>。构造函数的好处在于，所有用同一个构造函数创建的对象均有相同的属性和方法。<br>&emsp;&emsp;在JavaScript中，构造函数和普通函数没有绝对语法上的区别，为了区别它们，我们将构造函数的首字母大写。<br>&emsp;&emsp;当你调用new操作符创建对象的时候，new会自动创建this对象，且其类型就是构造函数的类型。构造函数本身不需要返回值，new操作符会自动帮你返回this对象。<br>&emsp;&emsp;你可以用instanceof操作符来获取对象的类型。你也可以用构造函数属性来检查一个对象的类型。每个对象在创建的时候都会自动拥有一个构造器属性，其中包含一个指向其构造函数的引用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(),</span><br><span class="line">    person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2 <span class="keyword">instanceof</span> Person);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.constructor);<span class="comment">//[Function: Person]</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.constructor);<span class="comment">//[Function: Person]</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;注意：如果忘记使用new操作符，会导致this指向的是全局对象，从而导致很多意想不到的问题，如何去解决这个问题，可以参考的方式下面的两种方式，构造函数内部进行错误检查并处理。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PersonSafeMethod</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// if (!(this instanceof PersonSafeMethod)) &#123;</span></span><br><span class="line">    <span class="comment">//     return new PersonSafeMethod(name);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">if</span> (!(<span class="keyword">this</span>.constructor === PersonSafeMethod)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PersonSafeMethod(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person3 = PersonSafeMethod(<span class="string">'illuSioN4ng'</span>);</span><br><span class="line">person3.sayName();</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;构造函数能够允许你给对象配置相同的属性，但是构造函数并没有消除代码的冗余，如果想要所有的对象实例共享一个方法从而达到更加高效的目的的话，这样就需要用到原型对象了。<br>&emsp;&emsp;几乎所有的函数都有一个名为prototype的属性，该属性是一个原型对象用来创建新的对象实例。例如，<code>hasOwnProperty()</code>方法被定义在泛用对象<code>Object</code>的原型对象中，但可以被任何对象当做自己的属性访问。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    title: <span class="string">'JavaScript Learning'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'title'</span> <span class="keyword">in</span> book);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(book.hasOwnProperty(<span class="string">'title'</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hasOwnProperty'</span> <span class="keyword">in</span>  book);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(book.hasOwnProperty(<span class="string">'hasOwnProperty'</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.hasOwnProperty(<span class="string">'hasOwnProperty'</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>鉴别一个属性是否是原型属性</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPrototypeProperty</span>(<span class="params">obj, name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name <span class="keyword">in</span> obj &amp;&amp; !obj.hasOwnProperty(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(hasPrototypeProperty(book, <span class="string">'title'</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(hasPrototypeProperty(book, <span class="string">'hasOwnProperty'</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><h2 id="prototype-属性"><a href="#prototype-属性" class="headerlink" title="[[prototype]]属性"></a>[[prototype]]属性</h2><p>&emsp;&emsp;一个对象实例通过内部属性[[prototype]]跟踪其原型对象。该属性是一个指向该实例使用的原型对象的指针。当你用new关键字创建一个新的对象时，构造函数的原型对象会被赋给该对象的<code>[[prototype]]</code>属性。<br>&emsp;&emsp;你可以用<code>Object.getPrototypeOf()</code>方法来读取<code>[[prototype]]</code>的值。<strong>大部分js引擎在所有的对象上都支持一个<code>__proto__</code>的属性，该属性使你可以直接读写`[[prtotype]]属性。ES6规范</strong><br>&emsp;&emsp;你也可以用<code>isPrototypeOf()</code>方法检查一个对象是否是另外一个对象的原型对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person1));<span class="comment">//Person &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype);<span class="comment">//Person &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.__proto__);<span class="comment">//Person &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(person1));<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>&emsp;&emsp;当读取一个对象的属性或者方法的时候，JavaScript引擎首先在该对象的自由属性上去查找属性名字。如果找到则返回，如果自有属性中没有该属性，则会搜索<code>[[prototype]]</code>中指向的对象。如果找到则返回找不到继续往原型对象的原型对象中去查找。这个查找路线就是原型链。</p><h2 id="在构造函数中使用原型对象"><a href="#在构造函数中使用原型对象" class="headerlink" title="在构造函数中使用原型对象"></a>在构造函数中使用原型对象</h2><p>&emsp;&emsp;原型对象的共享机制使得它们成为一次性为所有对象定义方法的理想手段。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person2</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person2.prototype = &#123;</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;,</span><br><span class="line">    favorites: []</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person4 = <span class="keyword">new</span> Person2(<span class="string">'illuSioN4ng'</span>),</span><br><span class="line">    person5 = <span class="keyword">new</span> Person2(<span class="string">'GodYao'</span>);</span><br><span class="line">person4.sayName();</span><br><span class="line">person5.sayName();</span><br><span class="line">person4.favorites.push(<span class="string">'apple'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person5.favorites);<span class="comment">//[ 'apple' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.constructor);<span class="comment">//[Function: Person]</span></span><br><span class="line"><span class="built_in">console</span>.log(person5.constructor);<span class="comment">//[Function: Object]</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;上例中可以看出，构造函数的原型对象对于使用构造函数创建的新的对象来说都是共享的。如：favorites数组。<br>&emsp;&emsp;但是上例中原型使用对象字面形式来写有一个坏处，就是constructor指向会出错。这个时候我们就要手动去设置constructor来避免这种错误。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person3</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person2.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person3,//显示的置顶原型对象的<span class="keyword">constructor</span>，一般放在原型对象属性的首位来写</span><br><span class="line">    sayName: function () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;,</span><br><span class="line">    favorites: []</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person6 = <span class="keyword">new</span> Person3(<span class="string">'illuSioN4ng'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person6.constructor);<span class="comment">//[Function: Person3]</span></span><br></pre></td></tr></table></figure></p><h2 id="改变原型对象"><a href="#改变原型对象" class="headerlink" title="改变原型对象"></a>改变原型对象</h2><p>&emsp;&emsp;给定类型的所有对象实例都共享一个原型对象，所以你可以一次性扩展所有的对象实例。<strong>[[prototype]]属性只包含了一个指向原型对象的指针，任何对象实例对于原型对象的修改都能立即表现在所有对象实例中。</strong><br>&emsp;&emsp;还有一个有趣的现象。当你在一个对象上使用Object.seal()或者Object.freeze()时，完全是在操作对象的自有属性。你无法添加自有属性或者改变自有属性，但是你可以操作原型对象来扩展实例。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;构造函数就是用new操作符调用的普通函数。为了区分构造函数和普通函数，我们一般将构造函数的首字母大写。可以使用<code>instanceof</code>操作符或者直接访问<code>constructor</code>属性来鉴别对象是被哪个构造函数创建。<br>&emsp;&emsp;每一个函数都有一个<code>prototype</code>属性，它定义了该构造函数创建的所有对象实例的共享属性。通常，共享方法和原始值被定义在原型对象中，而其他属性都定义在构造函数中。<code>constructor</code>属性实际上被定义在原型对象里供所有对象实例共享。<br>&emsp;&emsp;原型对象被保存在对象实例内部的<code>[[prototype]]</code>属性中，这个属性是一个引用而不是一个拷贝副本。由于JavaScript查找属性的机制，对于原型对象的修改都能立即反应在所有的对象实例中。当你访问一个属性的时候，JavaScript根据原型链一次查找。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;构造函数&quot;&gt;&lt;a href=&quot;#构造函数&quot; class=&quot;headerlink&quot; title=&quot;构造函数&quot;&gt;&lt;/a&gt;构造函数&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;构造函数就是你用new创建对象时调用的函数。例如&lt;code&gt;Obeject&lt;/code&gt;、&lt;code
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://illuSioN4ng.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://illuSioN4ng.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
