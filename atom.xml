<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>illuSioN4ng&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://illuSioN4ng.github.io/"/>
  <updated>2018-12-10T03:15:34.777Z</updated>
  <id>http://illuSioN4ng.github.io/</id>
  
  <author>
    <name>illuSioN4ng_uestc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>css-flex</title>
    <link href="http://illuSioN4ng.github.io/2018/12/10/CSS-2-flex/"/>
    <id>http://illuSioN4ng.github.io/2018/12/10/CSS-2-flex/</id>
    <published>2018-12-10T12:22:24.000Z</published>
    <updated>2018-12-10T03:15:34.777Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<strong>CSS3 弹性盒子</strong>(<strong>Flexible Box</strong> 或 <strong>Flexbox</strong>)，是一种用于在页面上布置元素的布局模式，使得当页面布局必须适应不同的屏幕尺寸和不同的显示设备时，元素可预测地运行。对于许多应用程序，弹性盒子模型提供了对块模型的改进，因为它不使用浮动，flex容器的边缘也不会与其内容的边缘折叠。<br>&emsp;&emsp;在定义方面来说，弹性布局是指通过调整其内元素的宽高，从而在任何显示设备上实现对可用显示空间最佳填充的能力。弹性容器扩展其内元素来填充可用空间，或将其收缩来避免溢出。    </p><h2 id="相关词汇"><a href="#相关词汇" class="headerlink" title="相关词汇"></a>相关词汇</h2><p>&emsp;&emsp;如下图中是一个 <code>flex-direction</code> 属性为 <code>row</code> 的弹性容器，意味着其内的弹性项目将根据既定书写模式沿主轴水平排列，其方向为元素的文本流方向，在这个例子里，为从左到右。<br><img src="/img/css/flexbox.png" alt="flexbox">    </p><h3 id="弹性容器（Flex-Container）"><a href="#弹性容器（Flex-Container）" class="headerlink" title="弹性容器（Flex Container）"></a>弹性容器（Flex Container）</h3><p>&emsp;&emsp;包含着弹性项目的父元素。通过设置 display 属性的值为 flex 或 inline-flex 来定义弹性容器。    </p><h3 id="弹性项目（Flex-item）"><a href="#弹性项目（Flex-item）" class="headerlink" title="弹性项目（Flex item）"></a>弹性项目（Flex item）</h3><p>&emsp;&emsp;弹性容器的每个子元素都称为弹性项目。弹性容器直接包含的文本将被包覆成匿名弹性单元。    </p><h3 id="轴（Axis）"><a href="#轴（Axis）" class="headerlink" title="轴（Axis）"></a>轴（Axis）</h3><p>&emsp;&emsp;每个弹性框布局包含两个轴。弹性项目沿其依次排列的那根轴称为<strong>主轴(main axis)</strong>。垂直于主轴的那根轴称为<strong>侧轴(cross axis)</strong>。</p><ul><li><code>flex-direction</code> 确立主轴。</li><li><code>justify-content</code> 定义了在当前行上，弹性项目沿主轴如何排布。</li><li><code>align-items</code> 定义了在当前行上，弹性项目沿侧轴默认如何排布。</li><li><code>align-self</code> 定义了单个弹性项目在侧轴上应当如何对齐，这个定义会覆盖由 <code>align-items</code> 所确立的默认值。<h3 id="方向（Direction）"><a href="#方向（Direction）" class="headerlink" title="方向（Direction）"></a>方向（Direction）</h3>&emsp;&emsp;弹性容器的<strong>主轴起点(<code>main start</code>)</strong>/<strong>主轴终点(<code>main end</code>)</strong>和<strong>侧轴起点(<code>cross start</code>)</strong>/<strong>侧轴终点(<code>cross end</code>)</strong>描述了弹性项目排布的起点与终点。它们具体取决于弹性容器的主轴与侧轴中，由 writing-mode 确立的方向（从左到右、从右到左，等等）。    </li><li><code>order</code> 属性将元素与序号关联起来，以此决定哪些元素先出现。</li><li><code>flex-flow</code> 属性是 <code>flex-direction</code> 和 <code>flex-wrap</code> 属性的简写，决定弹性项目如何排布。<h3 id="行（Line）"><a href="#行（Line）" class="headerlink" title="行（Line）"></a>行（Line）</h3>&emsp;&emsp;根据 <code>flex-wrap</code> 属性，弹性项目可以排布在单个行或者多个行中。此属性控制侧轴的方向和新行排列的方向。    <h1 id="尺寸-Dimension"><a href="#尺寸-Dimension" class="headerlink" title="尺寸(Dimension)"></a>尺寸(Dimension)</h1>&emsp;&emsp;根据弹性容器的主轴与侧轴，弹性项目的宽和高中，对应主轴的称为<strong>主轴尺寸(main size)</strong> ，对应侧轴的称为 <strong>侧轴尺寸(cross size)</strong>。</li><li><code>min-height</code> 与 `min-width 属性初始值将为 0。</li><li><code>flex</code> 属性是 <code>flex-grow</code>、<code>flex-shrink</code> 和 <code>flex-basis</code> 属性的简写，描述弹性项目的整体的伸缩性。</li></ul><h2 id="不影响弹性盒子的属性"><a href="#不影响弹性盒子的属性" class="headerlink" title="不影响弹性盒子的属性"></a>不影响弹性盒子的属性</h2><p>&emsp;&emsp;由于弹性盒子使用了不同的布局算法，某些属性用在弹性容器上没有意义：</p><ul><li>多栏布局模块的 <code>column-*</code> 属性对弹性项目无效。</li><li><code>float</code> 与 <code>clear</code> 对弹性项目无效。使用 <code>float</code> 将使元素的 <code>display</code> 属性计为<code>block</code>。</li><li><code>vertical-align</code> 对弹性项目的对齐无效。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;CSS3 弹性盒子&lt;/strong&gt;(&lt;strong&gt;Flexible Box&lt;/strong&gt; 或 &lt;strong&gt;Flexbox&lt;/strong&gt;)，是一种用于在页面上布置元素的布局模式，使得当页面布局必须适应不同的屏幕尺寸和不同
      
    
    </summary>
    
      <category term="CSS" scheme="http://illuSioN4ng.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://illuSioN4ng.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>最近工作的一些总结</title>
    <link href="http://illuSioN4ng.github.io/2018/11/05/work-summary/"/>
    <id>http://illuSioN4ng.github.io/2018/11/05/work-summary/</id>
    <published>2018-11-05T11:37:52.000Z</published>
    <updated>2018-11-05T12:49:55.936Z</updated>
    
    <content type="html"><![CDATA[<p>最近很久很久都没有认真写过总结了，自从从中学作业组抽身出来，就投入到新课堂互动组，就行 <code>electron-vue</code> 相关的开发中来，遇到了许许多多的问题，也针对业务进行可以也sdk或者组件的分装，后面有机会可以写一下，这篇文章，我想总结一下前段时间我遇到的一些问题，及解决方案。    </p><h2 id="临时文件的存放"><a href="#临时文件的存放" class="headerlink" title="临时文件的存放"></a>临时文件的存放</h2><p>之前很长一段时间都是在做 <code>PC Web</code> 相关的开发，第一次接触基于 <code>electron-vue</code> 的桌面应用的开发，期间开发了一套基于 <code>electron</code> 的桌面截屏插件 <code>short-capture</code>，因为团队内只有我一个人使用 <code>Mac</code> 所以有一些地方需要单独兼容 <code>Mac</code> ，只能自己去摸索，比如截图文件的存储地址，后来经过查阅相关资料了解到，<code>Windows</code> 系统中一般将软件的临时数据等信息存在 <code>C:\Users\Admin(用户名)\AppData</code> 中，<code>Mac</code> 中则存在 <code>~/Library/Application\ Support</code> 这种。</p><h2 id="跨平台截图绝对路径展示-mac失效问题"><a href="#跨平台截图绝对路径展示-mac失效问题" class="headerlink" title="跨平台截图绝对路径展示 mac失效问题"></a>跨平台截图绝对路径展示 mac失效问题</h2><p>因为本地截图成功后会返回一个本地绝对路径给回调函数，但是 <code>Mac</code> 系统中会直接将这个绝对地址附在本地 <code>localhost:8020</code> 后，导致本地图片加载不出来，这个问题纠结了我很久，后来灵光一闪，既然文件路径错了，走 <code>HTTP</code> 协议不行，为何不用<strong> <code>file</code> </strong>协议，配合 <code>Vue</code> 的 <code>filters</code> 很容易就可以实现了：<br><img src="https://ws1.sinaimg.cn/large/8c55dc23ly1fwxfrk1nozj20vk0b6dgu.jpg" alt="prefixer code">    </p><h2 id="JavaScript中对一个数取反"><a href="#JavaScript中对一个数取反" class="headerlink" title="JavaScript中对一个数取反"></a>JavaScript中对一个数取反</h2><p>互动组中有一个学生讲和纸笔直播的功能，当中涉及到画笔的切换和板擦的切换。当中画笔和板擦的颜色切换，安卓端直接发给我一个负数（如：-16777216），当时也纳闷了很久，后来才想明白，其实只需要做一侧补码操作就可以得到解码后的十六进制字符串，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// * colorNum = -16777216</span></span><br><span class="line">(colorNum + <span class="built_in">parseInt</span>(<span class="string">'ffffffff'</span>, <span class="number">16</span>) + <span class="number">1</span>)</span><br><span class="line"><span class="comment">// * ff000000 前两位为透明度</span></span><br></pre></td></tr></table></figure></p><h2 id="编码后字符串长度"><a href="#编码后字符串长度" class="headerlink" title="编码后字符串长度"></a>编码后字符串长度</h2><p>这个项目中我这边还写了一套消息队列的js sdk，当中有一些消息长度的封装，因为一开始只涉及到英文指令，我直接用了 <code>String.prototype.length</code>，后来加上中文字符之后，就会导致 <code>mq-server</code> 解析消息长度就解析错误，因为消息经由 <code>utf8</code> 之后中文长度就会变了（<code>utf8</code>是变长编码），这时候就需要使用 <code>EcmaScript</code> 中的 <code>Buffer.byteLength</code>,返回一个字符串的实际字节长度。 这与 <code>String.prototype.length</code> 不同，因为那返回字符串的字符数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近很久很久都没有认真写过总结了，自从从中学作业组抽身出来，就投入到新课堂互动组，就行 &lt;code&gt;electron-vue&lt;/code&gt; 相关的开发中来，遇到了许许多多的问题，也针对业务进行可以也sdk或者组件的分装，后面有机会可以写一下，这篇文章，我想总结一下前段时间我
      
    
    </summary>
    
      <category term="electron" scheme="http://illuSioN4ng.github.io/categories/electron/"/>
    
    
      <category term="JavaScript" scheme="http://illuSioN4ng.github.io/tags/JavaScript/"/>
    
      <category term="Vue" scheme="http://illuSioN4ng.github.io/tags/Vue/"/>
    
      <category term="electron" scheme="http://illuSioN4ng.github.io/tags/electron/"/>
    
      <category term="electron-vue" scheme="http://illuSioN4ng.github.io/tags/electron-vue/"/>
    
  </entry>
  
  <entry>
    <title>需求定律</title>
    <link href="http://illuSioN4ng.github.io/2018/09/06/basic-economics-3/"/>
    <id>http://illuSioN4ng.github.io/2018/09/06/basic-economics-3/</id>
    <published>2018-09-06T02:27:13.000Z</published>
    <updated>2018-09-08T02:34:51.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求定律（Law-of-Demand）"><a href="#需求定律（Law-of-Demand）" class="headerlink" title="需求定律（Law of Demand）"></a>需求定律（Law of Demand）</h2><p>需求定路也就是说：某种商品价格上升，需求量就会下降；价格下降，需求量就会上升。需求和价格之间存在反向关系。</p><h2 id="相关产品价格和需求"><a href="#相关产品价格和需求" class="headerlink" title="相关产品价格和需求"></a>相关产品价格和需求</h2><p>需求定律成立的前提是，其他因素保持不变。其他这些因素包括相关产品价格，当相关产品价格变化时，需求曲线也会产生整体变化。相关产品包括替代品和互补品。</p><h2 id="收入、人口、偏好变化"><a href="#收入、人口、偏好变化" class="headerlink" title="收入、人口、偏好变化"></a>收入、人口、偏好变化</h2><p>需求定律成立的前提是，其他因素保持不变。其他这些因素包括收入、人口、偏好变化。收入和人口增加时，一般商品的需求会增加，偏好变化时，需求也会相应的变化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;需求定律（Law-of-Demand）&quot;&gt;&lt;a href=&quot;#需求定律（Law-of-Demand）&quot; class=&quot;headerlink&quot; title=&quot;需求定律（Law of Demand）&quot;&gt;&lt;/a&gt;需求定律（Law of Demand）&lt;/h2&gt;&lt;p&gt;需求
      
    
    </summary>
    
      <category term="Basic Economics" scheme="http://illuSioN4ng.github.io/categories/Basic-Economics/"/>
    
    
      <category term="basic-economics" scheme="http://illuSioN4ng.github.io/tags/basic-economics/"/>
    
  </entry>
  
  <entry>
    <title>通过投资的经济增长</title>
    <link href="http://illuSioN4ng.github.io/2018/09/02/basic-economics-2/"/>
    <id>http://illuSioN4ng.github.io/2018/09/02/basic-economics-2/</id>
    <published>2018-09-02T02:13:08.000Z</published>
    <updated>2018-09-08T02:28:58.609Z</updated>
    
    <content type="html"><![CDATA[<h2 id="通过投资的经济增长"><a href="#通过投资的经济增长" class="headerlink" title="通过投资的经济增长"></a>通过投资的经济增长</h2><p>生产可能性边界可以不是固定不变的，它可以变化，通过投资，生产可能性边界会往外扩张，这就是经济增长。</p><h2 id="比较优势专业化和贸易所得"><a href="#比较优势专业化和贸易所得" class="headerlink" title="比较优势专业化和贸易所得"></a>比较优势专业化和贸易所得</h2><p>如果说A生产一种产品的机会成本低于B，那么对于这种产品，A就拥有相对应B的比较优势。这时，A就应该专业化生产这种商品，而B也专业化生产B具有比较优势的产品，这样一来，双方就可以从贸易中获利。    </p><h2 id="比较优势和绝对优势"><a href="#比较优势和绝对优势" class="headerlink" title="比较优势和绝对优势"></a>比较优势和绝对优势</h2><p>绝对优势是说相同投入时产出更多，这样的优势是绝对优势。比较优势考虑的不是这个，比较优势关心的是谁的机会成本更加低。具有绝对优势的一方不一定具有相对优势。<br>生产率提高，绝对优势提高，但是比较优势可能下降；<br>任何交易只要是机会成本低，那么就是一笔好的买卖；<br>通过贸易来降低机会成本（比自行生产的机会成本低），双赢，从而带来超越生产可能性边界的结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;通过投资的经济增长&quot;&gt;&lt;a href=&quot;#通过投资的经济增长&quot; class=&quot;headerlink&quot; title=&quot;通过投资的经济增长&quot;&gt;&lt;/a&gt;通过投资的经济增长&lt;/h2&gt;&lt;p&gt;生产可能性边界可以不是固定不变的，它可以变化，通过投资，生产可能性边界会往外扩张，这
      
    
    </summary>
    
      <category term="Basic Economics" scheme="http://illuSioN4ng.github.io/categories/Basic-Economics/"/>
    
    
      <category term="basic-economics" scheme="http://illuSioN4ng.github.io/tags/basic-economics/"/>
    
  </entry>
  
  <entry>
    <title>基于SVG path的弧形文字</title>
    <link href="http://illuSioN4ng.github.io/2018/08/28/CSS-1-svg/"/>
    <id>http://illuSioN4ng.github.io/2018/08/28/CSS-1-svg/</id>
    <published>2018-08-28T09:27:46.000Z</published>
    <updated>2018-08-28T13:50:30.744Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;最近在做课堂互动的演示版本的时候，遇到了一个简单的需求，即教师端点击表扬按钮的时候，学生端需要收到如下的一个效果：<br><img src="http://ww1.sinaimg.cn/large/8c55dc23gy1fupotdkqsrj207606tdgw.jpg" alt="表扬"><br>&emsp;&emsp;虽然某些Javascript插件中可以实现类似的效果，不过这些脚本需要把所有的文字包裹在独立的 <code>&lt;span&gt;&lt;/span&gt;</code> 中，在分别将各个 <code>span</code> 旋转定位，从而形成，这时候就想到《CSS揭秘》中提到的SVG原生支持以任何路径排队的文字，所以环形文字和弧形文字都非常简单来实现了。    </p><h2 id="基本实现思路"><a href="#基本实现思路" class="headerlink" title="基本实现思路"></a>基本实现思路</h2><p>&emsp;&emsp;在SVG中，让文本按照路径排列的基本方法就是使用 <code>&lt;textpath&gt;</code> 来包裹住这段文本，再把它们装进一个 <code>&lt;text&gt;</code> 元素中，这个 <code>&lt;textpath&gt;</code> 标签还需要在它的 <code>id</code> 属性中引用一个 <code>&lt;path&gt;</code> 元素，然后就可以用这个 <code>&lt;path&gt;</code> 定义我们想要的路径。    </p><iframe height="265" scrolling="no" title="LJZreG" src="//codepen.io/illuSioN4ng/embed/LJZreG/?height=265&theme-id=0&default-tab=html,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/illuSioN4ng/pen/LJZreG/" target="_blank" rel="noopener">LJZreG</a> by illuSioN4ng (<a href="https://codepen.io/illuSioN4ng" target="_blank" rel="noopener">@illuSioN4ng</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe><p>&emsp;&emsp;如上图，我们初始化路径为一个黑色的圆，其中我们使用viewBox来定义它的大小，它可以自适应外层容器的尺寸。<br>&emsp;&emsp;弧形路径用到的参数比较多， <code>a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy</code> ，弧形命令A的前两个参数分别是x轴半径和y轴半径，  <code>x-axis-rotation</code> 为x轴旋转角度<br><code>large-arc-flag</code>（角度大小） 和<code>sweep-flag</code>（弧线方向）， <code>large-arc-flag</code> 决定弧线是大于还是小于180度，0表示小角度弧，1表示大角度弧。 <code>sweep-flag</code> 表示弧线的方向，0表示从起点到终点沿逆时针画弧，1表示从起点到终点沿顺时针画弧。所以上述 <code>path</code> 命令是先移动到点（0, 50）,顺时针画一个黑色的圆（z是闭合路径）。     </p><p>&emsp;&emsp;效果如下：    </p><iframe height="265" scrolling="no" title="MqeXvZ" src="//codepen.io/illuSioN4ng/embed/MqeXvZ/?height=265&theme-id=0&default-tab=html,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/illuSioN4ng/pen/MqeXvZ/" target="_blank" rel="noopener">MqeXvZ</a> by illuSioN4ng (<a href="https://codepen.io/illuSioN4ng" target="_blank" rel="noopener">@illuSioN4ng</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe><p>&emsp;&emsp;样式加上<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.circular</span> <span class="selector-tag">path</span> &#123;</span><br><span class="line">  <span class="attribute">fill</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.circular</span> <span class="selector-tag">svg</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: visible;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">3em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><iframe height="265" scrolling="no" title="YOWveN" src="//codepen.io/illuSioN4ng/embed/YOWveN/?height=265&theme-id=0&default-tab=html,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/illuSioN4ng/pen/YOWveN/" target="_blank" rel="noopener">YOWveN</a> by illuSioN4ng (<a href="https://codepen.io/illuSioN4ng" target="_blank" rel="noopener">@illuSioN4ng</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe><p>&emsp;&emsp;知道怎么画环形文字之后，弧形文字就简单了，直接上代码吧：    </p><iframe height="265" scrolling="no" title="环形文字" src="//codepen.io/illuSioN4ng/embed/xJoEYm/?height=265&theme-id=0&default-tab=html,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/illuSioN4ng/pen/xJoEYm/" target="_blank" rel="noopener">环形文字</a> by illuSioN4ng (<a href="https://codepen.io/illuSioN4ng" target="_blank" rel="noopener">@illuSioN4ng</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe><p>&emsp;&emsp;大概思路就是这样啦，贝塞尔曲线路径具体的属性含义如下：     </p><pre><code>C x1 y1, x2 y2, x y (or c dx1 dy1, dx2 dy2, dx dy)</code></pre><p>&emsp;&emsp;最后一个坐标(x,y)表示的是曲线的终点，另外两个坐标是控制点，(x1,y1)是起点的控制点，(x2,y2)是终点的控制点。</p><p>&emsp;&emsp;以上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;最近在做课堂互动的演示版本的时候，遇到了一个简单的需求，即教师端点击表扬按钮的时候，学生端需要收到如下的一个效果：&lt;br&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/8c55dc23gy1fupotdkqsrj2076
      
    
    </summary>
    
      <category term="CSS" scheme="http://illuSioN4ng.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://illuSioN4ng.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>心理学-1</title>
    <link href="http://illuSioN4ng.github.io/2018/08/27/psychology-1/"/>
    <id>http://illuSioN4ng.github.io/2018/08/27/psychology-1/</id>
    <published>2018-08-27T02:04:50.000Z</published>
    <updated>2018-09-08T02:11:27.343Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在平凡中成为焦点"><a href="#在平凡中成为焦点" class="headerlink" title="在平凡中成为焦点"></a>在平凡中成为焦点</h2><ol><li>养成读书的习惯</li><li>交比自己成熟的朋友，学习他们的思考方式</li><li>提高自身品质，扩增词汇量</li></ol><h2 id="怎样安慰别人"><a href="#怎样安慰别人" class="headerlink" title="怎样安慰别人"></a>怎样安慰别人</h2><ol><li>共情：展示你的同理心。表达形式为：评价 +  问句</li><li>提供倾诉的机会。用疑问句打开话题</li><li>提供情感的支持</li><li>提供行动上的支持（自身主动提出并去做）</li></ol><h2 id="高情商"><a href="#高情商" class="headerlink" title="高情商"></a>高情商</h2><p>五个维度：</p><ol><li>了解自我</li><li>情绪管理</li><li>自我激励</li><li>同理心</li><li>社交能力</li></ol><p>提高情商的方法：</p><ol><li>提高自己调节他人情绪的能力</li><li>提高同理心，与他人情绪一致</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;在平凡中成为焦点&quot;&gt;&lt;a href=&quot;#在平凡中成为焦点&quot; class=&quot;headerlink&quot; title=&quot;在平凡中成为焦点&quot;&gt;&lt;/a&gt;在平凡中成为焦点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;养成读书的习惯&lt;/li&gt;
&lt;li&gt;交比自己成熟的朋友，学习他们的思考方式&lt;/li
      
    
    </summary>
    
      <category term="psychology" scheme="http://illuSioN4ng.github.io/categories/psychology/"/>
    
    
      <category term="psychology" scheme="http://illuSioN4ng.github.io/tags/psychology/"/>
    
  </entry>
  
  <entry>
    <title>微观经济学几个基本概念</title>
    <link href="http://illuSioN4ng.github.io/2018/08/26/basic-economics-1/"/>
    <id>http://illuSioN4ng.github.io/2018/08/26/basic-economics-1/</id>
    <published>2018-08-26T13:22:12.000Z</published>
    <updated>2018-09-08T02:28:55.788Z</updated>
    
    <content type="html"><![CDATA[<h2 id="生产可能性边界（PPF：Production-Possiblities-Frontier）"><a href="#生产可能性边界（PPF：Production-Possiblities-Frontier）" class="headerlink" title="生产可能性边界（PPF：Production Possiblities Frontier）"></a>生产可能性边界（PPF：Production Possiblities Frontier）</h2><p>&emsp;&emsp;用来表示经济社会在既定资源和技术条件下所能生产的各种商品的最大数量的组合。    </p><h2 id="机会成本-（Opportunity-Cost）Or-边际成本-（Marginal-Cost）"><a href="#机会成本-（Opportunity-Cost）Or-边际成本-（Marginal-Cost）" class="headerlink" title="机会成本 （Opportunity Cost）Or 边际成本 （Marginal Cost）"></a>机会成本 （Opportunity Cost）Or 边际成本 （Marginal Cost）</h2><p>&emsp;&emsp;指为了某种物品所要放弃另一种物品的机会成本又叫边际成本。   </p><h2 id="递增机会成本-（Increasing-Opportunity-Cost）"><a href="#递增机会成本-（Increasing-Opportunity-Cost）" class="headerlink" title="递增机会成本 （Increasing Opportunity Cost）"></a>递增机会成本 （Increasing Opportunity Cost）</h2><p>&emsp;&emsp;随着得到某一种物品的数量的增加，需要放弃另外一种物品的量也随之增加。    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;生产可能性边界（PPF：Production-Possiblities-Frontier）&quot;&gt;&lt;a href=&quot;#生产可能性边界（PPF：Production-Possiblities-Frontier）&quot; class=&quot;headerlink&quot; title=&quot;生产
      
    
    </summary>
    
      <category term="Basic Economics" scheme="http://illuSioN4ng.github.io/categories/Basic-Economics/"/>
    
    
      <category term="basic-economics" scheme="http://illuSioN4ng.github.io/tags/basic-economics/"/>
    
  </entry>
  
  <entry>
    <title>What&#39;s Vuex</title>
    <link href="http://illuSioN4ng.github.io/2018/08/18/vuex-1-what%20is%20vuex/"/>
    <id>http://illuSioN4ng.github.io/2018/08/18/vuex-1-what is vuex/</id>
    <published>2018-08-18T06:58:05.000Z</published>
    <updated>2018-08-26T13:37:38.643Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。<br>&emsp;&emsp;状态管理应该包含以下几部分：</p><ul><li><strong>state</strong> 驱动应用的数据源</li><li><strong>view</strong> 已声明式将 state 映射到视图</li><li><strong>actions</strong> 响应在 view 上的用户输入导致的状态变化 </li></ul><p>&emsp;&emsp;下面是一个单向数据流的极简示意图：<br>  <img src="https://vuex.vuejs.org/flow.png" style="width: 100%; max-width: 450px;">  </p><p>&emsp;&emsp;但是，当应用遇到多个组件共享状态时，单向数据流的简洁性就很容易被破<br>  坏：</p><ul><li>多个视图依赖于同一状态</li><li>来自不同视图的行为需要变更同一状态</li></ul><p>&emsp;&emsp;对于问题一，传参的方法对于多层嵌套的组件将会变得非常繁琐，并且对于兄弟组件间的状态传递无能为力。对于问题二，我们通常采用父子组件直接饮用  或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致代码无法维护。<br>&emsp;&emsp;Vuex 就是为了把组件的状态抽离出来，以一个全局单例模式，通过定义和隔离管理中的各种概念并强烈遵守一定的规则，来管理。<br>&emsp;&emsp;Vuex 背后的基本思想，借鉴了 Flux、Redux、和 The Elm Architecture。与其他模式不同的是，Vuex 是专门为 Vue.js 设计的状态管理库，以利用 Vue.js 的细粒度数据响应机制来进行高效的状态更新。</p><p><img src="https://vuex.vuejs.org/vuex.png" alt="vuex"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;Vuex 是一个专为 Vue.js 应用程序开发的&lt;strong&gt;状态管理模式&lt;/strong&gt;。它采用集中式存储应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。&lt;br&gt;&amp;emsp;&amp;emsp;状态管理应该包含以下几部分：&lt;/
      
    
    </summary>
    
      <category term="Vue" scheme="http://illuSioN4ng.github.io/categories/Vue/"/>
    
    
      <category term="JavaScript" scheme="http://illuSioN4ng.github.io/tags/JavaScript/"/>
    
      <category term="Vue" scheme="http://illuSioN4ng.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>knowledge-map</title>
    <link href="http://illuSioN4ng.github.io/2018/08/05/knowledge-map/"/>
    <id>http://illuSioN4ng.github.io/2018/08/05/knowledge-map/</id>
    <published>2018-08-05T01:37:09.000Z</published>
    <updated>2018-08-05T13:42:05.301Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;今年三月底介入新业务线进行 hybird 开发至今，总算告一段落，期间经历了<br>许多，也成长了许多，其中经历最深刻的一个功能点就是个性化作业的知识图谱的模块，下<br>面就简单的记录一下知识图谱相关的知识。 &emsp;&emsp;知识图谱顾名思义就是将知识点<br>之间的关系通过关系图的方式进行展示，包括前置后置节点，以及学生掌握程度等信息。如<br>下图所示<br>：<img src="http://ww1.sinaimg.cn/large/8c55dc23gy1ftyl6thdn4j21ay10onkk.jpg" alt="知识图谱"></p><h2 id="图谱的特点"><a href="#图谱的特点" class="headerlink" title="图谱的特点"></a>图谱的特点</h2><p>&emsp;&emsp;图谱的实现是需要经过多方同事的共同努力 ，其主要特点如下：</p><ol><li>构建<ul><li>多学科教研老师梳理得到</li><li>知识点颗粒细、数量多、覆盖广，配备习题，支持多版本教材</li><li>知识点间有着前驱后继关系，表示学习的先后顺序</li></ul></li><li>定量描述<ul><li>可从图谱展示平台上直接展示结构</li><li>图谱连接边上有预先设计的权重，为知识点跳转概率</li><li>根据图谱结构，通过 pageRank 计算出每个知识点的重要程度</li></ul></li><li>更新优化<ul><li>教研可在图谱展示平台动态观看图谱并改动</li><li>使用学生答题数据生成动态模型，反映了知识点间的隐含关系。可以提供教 研进行<br>参考并直接用于推荐</li></ul></li></ol><h2 id="图谱的组成"><a href="#图谱的组成" class="headerlink" title="图谱的组成"></a>图谱的组成</h2><ol><li>锚点关系图谱</li></ol><ul><li>有向无环图</li><li>锚点重要程度定量化描述(PageRank)</li></ul><ol><li>锚点关系</li></ol><ul><li>根据学习先后顺序分为前驱、后继</li><li>关系边上有设定转移权重</li></ul><ol><li>锚点</li></ol><ul><li>教研以试题分类角度设定</li><li>表示一类题型相似、难度相近题目</li></ul><h2 id="图谱数据分析"><a href="#图谱数据分析" class="headerlink" title="图谱数据分析"></a>图谱数据分析</h2><p>&emsp;&emsp;具体分析如下图：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"code"</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="attr">"info"</span>: <span class="string">"操作成功"</span>,</span><br><span class="line">  <span class="attr">"result"</span>: &#123;</span><br><span class="line">    // 所有学生数量</span><br><span class="line">    "studentTotalCount": 16,</span><br><span class="line">    // 已覆盖知识点的掌握程度</span><br><span class="line">    "coverdAnchorPointMastery": 0.3051658455,</span><br><span class="line">    // 已掌握知识点数量</span><br><span class="line">    "masterAnchorPoint": 40,</span><br><span class="line">    // 知识点总数</span><br><span class="line">    "totalAnchorPoint": 50,</span><br><span class="line">    // 知识点数组</span><br><span class="line">    "anchorMappingData": [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"anchorPointId"</span>: <span class="string">"02_05_347"</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"已知解析式求函数定义域"</span>,</span><br><span class="line">        // 所属知识点类型 必会 拔高 高阶</span><br><span class="line">        "topicLayer": "definite",</span><br><span class="line">        "anchorTopicId": "6d72e77d-f865-403f-906f-cf95eac6f637",</span><br><span class="line">        // 前置知识点数组</span><br><span class="line">        "precursors": [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"anchorPointId"</span>: <span class="string">"02_05_346"</span>,</span><br><span class="line">            <span class="attr">"weight"</span>: <span class="number">0.0</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="literal">null</span></span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        // 后置知识点数组</span><br><span class="line">        "postcursors": null,</span><br><span class="line">        "catalogs": [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"code"</span>:</span><br><span class="line">              <span class="string">"233_12020300128-968_12020300128-968-36327_12020300128-968-36328"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="literal">null</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"code"</span>: <span class="string">"09_19020501-003_003_001"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="literal">null</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"code"</span>: <span class="string">"08_19020501-002_02_002"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="literal">null</span></span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        "knowledges": null,</span><br><span class="line">        "phase": null,</span><br><span class="line">        "subject": null,</span><br><span class="line">        "level": null,</span><br><span class="line">        "cards": null,</span><br><span class="line">        "videos": null,</span><br><span class="line">        "anchorMastery": -1.0,</span><br><span class="line">        "anchorUserNum": 0,</span><br><span class="line">        "x": 5,</span><br><span class="line">        "y": 5</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    // 包含的知识点类型数组 必会、拔高、高阶</span><br><span class="line">    "examinationTypeList": [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"totalAnchorPoint"</span>: <span class="number">22</span>,</span><br><span class="line">        <span class="attr">"masterAnchorPoint"</span>: <span class="number">22</span>,</span><br><span class="line">        <span class="attr">"coverdAnchorPointMastery"</span>: <span class="number">0.3479859241</span>,</span><br><span class="line">        <span class="attr">"examinationTypeCode"</span>: <span class="string">"definite"</span>,</span><br><span class="line">        <span class="attr">"examinationTypeName"</span>: <span class="string">"必会题"</span>,</span><br><span class="line">        <span class="attr">"sort"</span>: <span class="number">1</span>,</span><br><span class="line">        // 包含知识点数组</span><br><span class="line">        "anchorPoints": [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"anchorTopicId"</span>: <span class="string">"6d72e77d-f865-403f-906f-cf95eac6f637"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"已知解析式求函数定义域"</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"totalAnchorPoint"</span>: <span class="number">15</span>,</span><br><span class="line">        <span class="attr">"masterAnchorPoint"</span>: <span class="number">15</span>,</span><br><span class="line">        <span class="attr">"coverdAnchorPointMastery"</span>: <span class="number">0.2627470402</span>,</span><br><span class="line">        <span class="attr">"examinationTypeCode"</span>: <span class="string">"raise"</span>,</span><br><span class="line">        <span class="attr">"examinationTypeName"</span>: <span class="string">"拔高题"</span>,</span><br><span class="line">        <span class="attr">"sort"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">"anchorPoints"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"anchorTopicId"</span>: <span class="string">"3bea88ba-14d9-4060-a7df-635508adf1bd"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"函数创新类问题—特殊点问题"</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"totalAnchorPoint"</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">"masterAnchorPoint"</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">"coverdAnchorPointMastery"</span>: <span class="number">0.2032459627</span>,</span><br><span class="line">        <span class="attr">"examinationTypeCode"</span>: <span class="string">"higher"</span>,</span><br><span class="line">        <span class="attr">"examinationTypeName"</span>: <span class="string">"高阶题"</span>,</span><br><span class="line">        <span class="attr">"sort"</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">"anchorPoints"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"anchorTopicId"</span>: <span class="string">"b5b43871-038e-40ca-bc8e-84df51264f2f"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"数形结合的应用"</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图谱的最终效果"><a href="#图谱的最终效果" class="headerlink" title="图谱的最终效果"></a>图谱的最终效果</h2><p>&emsp;&emsp;代码中其实还是有很多业务逻辑，并没有很完全的去抽离，以后有机会再来做的。<br>&emsp;&emsp;最终效果如下图所示：<br><img src="http://ww1.sinaimg.cn/large/8c55dc23gy1ftz5d2vyhyj21fi0yotk9.jpg" alt="图谱"><br>&emsp;&emsp;详细代码请移步codepen上去看。</p><p></p><p data-height="500" data-theme-id="0" data-slug-hash="EppgGG" data-default-tab="js,result" data-user="illuSioN4ng" data-pen-title="knowledge-map" class="codepen">See the Pen <a href="https://codepen.io/illuSioN4ng/pen/EppgGG/" target="_blank" rel="noopener">knowledge-map</a> by illuSioN4ng (<a href="https://codepen.io/illuSioN4ng" target="_blank" rel="noopener">@illuSioN4ng</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;今年三月底介入新业务线进行 hybird 开发至今，总算告一段落，期间经历了&lt;br&gt;许多，也成长了许多，其中经历最深刻的一个功能点就是个性化作业的知识图谱的模块，下&lt;br&gt;面就简单的记录一下知识图谱相关的知识。 &amp;emsp;&amp;emsp;知识图谱顾名思
      
    
    </summary>
    
      <category term="Summary" scheme="http://illuSioN4ng.github.io/categories/Summary/"/>
    
    
      <category term="JavaScript" scheme="http://illuSioN4ng.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Promise对象</title>
    <link href="http://illuSioN4ng.github.io/2018/01/21/ESx-promise/"/>
    <id>http://illuSioN4ng.github.io/2018/01/21/ESx-promise/</id>
    <published>2018-01-21T07:20:08.000Z</published>
    <updated>2018-01-21T15:06:48.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>&emsp;&emsp;<code>Promise</code> 网上有很多的JavaScript实现，ES6中将它写进了语言标准，统一了语言写法，并提供了原生的 <code>Promise</code> 对象的支持。<br>&emsp;&emsp;所谓 <code>Promise</code> 就是一个对象用来传递异步操作的信息。 <code>Promise</code> 对象有以下两个特点：    </p><ol><li>对象的状态不受外界的影响。 <code>Promise</code> 代表一种异步操作，它一共有三种状态：Pending（未完成）、Resolved（已完成，又叫fulfilled）、Rejected（已失败）。只有异步操作的结果可以决定当前是哪一种状态，任何操作都不可以改变这个状态；</li><li>一旦状态改变之后就不能再次修改，任何时候都可以得到这个结果状态。 <code>Promise</code>对象的状态改变一共有两种方式：从Pending变为Resolved，或者从Pending变为Rejected。只要其中一种发生，状态就会凝固，不会再发生改变，Promise会一直保持这个状态。</li></ol><p>&emsp;&emsp;先简单说下 <code>Promise</code> 的优缺点，有点上面已经提到了，就是可以将异步操作流程按照同步操作的流程表达出来，避免了层层嵌套的回调写法，此外， <code>Promise</code> 提供了统一的接口，使伊布流程控制更加简单。不过同样有一些缺点，比如： <code>Promise</code> 无法取消，一旦新建它就会一直执行下去，无法中途停止，其次，如果不设置回调函数的话， <code>Promise</code> 的错误不会立即被捕获，在这 <code>Promise</code> 在Pending状态的时候，我们无法得知该状态是刚开始还是即将完成，换句话说，无法得知目前状态的具体进展。    </p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>&emsp;&emsp;ES6中规定 <code>Promise</code> 是一个构造函数，用来构建 <code>Promise</code> 实例对象。下面是一个简单的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// some code here</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>) &#123;</span><br><span class="line">    resolve(value)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp; <code>Promise</code> 构造函数接受一个函数作为参数，该函数接受两个参数分别代表 <code>Resolved</code>和 <code>Rejected</code> 状态时需要执行的函数。当 <code>Promise</code> 从Pending状态变为Resolved的时候调用resolve函数，并将异步调用的结果作为参数传递给resolve函数；当从pending状态变为Rejected状态的时候执行reject函数，并将错误信息传递给reject函数。<br>&emsp;&emsp; <code>Promise</code> 实例生成之后可以使用then方法来指定Resolved状态和Rejected函数的回调函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do somthing</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle the error</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;如果调用resolve函数和reject函数时带有参数，那么这些参数可以被传递给回调函数。reject函数通常参数是Error对象的实例，表示抛出错误；resolve函数的参数除了正常的值外，还可能是一个新的promise对象，因为异步操作的结果可能是一个值也可能是另外一个异步操作，具体可以看下下面的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do somthing</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do somthin</span></span><br><span class="line">  resolve(p1)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;上面的代码中，p1和p2都是Promise的实例对象，可以看到p2中的resolve函数的参数是p1，即一个异步操作返回另一个异步操作，这种情况下，p1的状态就传递给p2。也就是说p1的状态决定p2的状态，如果p1的状态是Pending的话，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经由Pending转变为Resolved或者Rejected的话，那么p2的回调就会立即执行。    </p><h2 id="Promise-prototype-then-函数"><a href="#Promise-prototype-then-函数" class="headerlink" title="Promise.prototype.then() 函数"></a>Promise.prototype.then() 函数</h2><p>&emsp;&emsp;<code>then</code> 函数是为Promise实例添加状态改变时的毁掉函数。前面说过then函数有两个参数分别是Resolve和Reject（可选）状态的回调函数。<code>then</code> 函数返回的是一个新的Promise实例，因此可以采用链式写法，即then方法后面继续调用另外一个then方法。采用链式的then写法可以指定一组按照次序调用的函数，这时前面的的函数可能返回的还是一个Promise对象（即有异步操作），而后一个Promise实例会等待该Promise对象状态发生改变的时候再被调用。    </p><h2 id="Promise-prototype-catch-函数"><a href="#Promise-prototype-catch-函数" class="headerlink" title="Promise.prototype.catch() 函数"></a>Promise.prototype.catch() 函数</h2><p>&emsp;&emsp;Promise.prototype.catch()函数其实是.then(null, rejection)的别名，用来指定发生错误时的回调函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">getJson(<span class="string">'url.your.site/data.json'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// handle the error</span></span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">getJson(<span class="string">'url.your.site/data.json'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// handle the error</span></span><br><span class="line">      <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;一般来说，不要在then函数中定义Rejected状态的回调函数，应该在then链式调用的最后使用catch方法来做。</p><blockquote><p>catch方法返回的还是一个Promise对象，因此后面还是可以链式调用then方法</p></blockquote><h2 id="Promise-all-方法和Promise-race-方法"><a href="#Promise-all-方法和Promise-race-方法" class="headerlink" title="Promise.all()方法和Promise.race()方法"></a>Promise.all()方法和Promise.race()方法</h2><p>&emsp;&emsp;Promise.all方法用于将多个Promise实例对象包装成一个新的Promise实例。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3])</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;上述代码中 Promise.all方法接受一个数组对象作为参数，数组里面所有的元素都是一个Promise实例对象。显然p的状态是由p1、p2、p3共同决定的，分为以下两种情况：    </p><ol><li>只有三者状态都转变为Fulfilled，p的状态才会变为Fulfilled，此时p1、p2、p3三者的返回值组成一个数组，返回给p的回调函数去处理；</li><li>只要三者之间有一个是Rejected状态，p的状态就会变成Rejected，此时第一个被Rejected的实例的返回值就会返回给p的回调函数。    </li></ol><p>&emsp;&emsp;Promise.race()方法和Promise.all()方法的功能不同之处在于，race方法是只需要参数数组中最先状态状态转变为Fulfilled的Promise实例的返回值，而不是等参数数组中所有的Promise对象都转变完成之后再传递。    </p><p>&emsp;&emsp;当然Promise还是有一些其他的方法，这里就不在赘述了，如果还有兴趣，可以去查找相应的文档，深入的了解一下。    </p><blockquote><p>参阅 <a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">ES 6标准入门 Promise 相关</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;&lt;code&gt;Promise&lt;/code&gt; 网上有很多的JavaScript实现，ES6中将它写进了语言标准，统一了语
      
    
    </summary>
    
      <category term="ESx" scheme="http://illuSioN4ng.github.io/categories/ESx/"/>
    
    
      <category term="ESx" scheme="http://illuSioN4ng.github.io/tags/ESx/"/>
    
      <category term="JavaScript" scheme="http://illuSioN4ng.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Generator函数</title>
    <link href="http://illuSioN4ng.github.io/2018/01/18/ESx-generator/"/>
    <id>http://illuSioN4ng.github.io/2018/01/18/ESx-generator/</id>
    <published>2018-01-18T13:08:33.000Z</published>
    <updated>2018-01-21T15:06:48.568Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;今天在看node.js相关内容的时候，遇到了async/await函数相关，然后想到了promise、generator函数，发现有点记忆混乱了，遂准备整理一下ES6相关的东西。（实际业务中用不到的东西真的是太容易遗忘了，虽然是好东西，能够带来极大的便利，可是业务上需要兼容低版本IE的限制，真的太大了 Orz~~）</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>&emsp;&emsp;<code>Generator</code> 函数是ES6语法提供的一种异步编程解决方案，语法行为和传统函数完全不同。从语法上来看，可以简单把 <code>Generator</code> 函数理解成一个状态机，封装多个内部状态。执行 <code>Generator</code> 函数会返回一个迭代器对象，所以 <code>Generator</code> 函数除了是一个状态机还是一个迭代对象生成函数，返回的迭代器可以一次访问 <code>Generator</code> 函数内部的所有状态。<br>&emsp;&emsp;形式上， <code>Generator</code> 是一个普通函数，但是有两个特征：1、function命令与函数名之间有一个星号；2、函数体内部使用yield语句定义不同的内部状态（ <code>yield</code> 在英语中的意思就是 “产出”的意思）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'over'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hw = helloWorldGenerator();</span><br><span class="line">hw.next(); <span class="comment">// &#123;value: "hello", done: false&#125;</span></span><br><span class="line">hw.next(); <span class="comment">// &#123;value: "world", done: false&#125;</span></span><br><span class="line">hw.next(); <span class="comment">// &#123;value: "over", done: true&#125;</span></span><br><span class="line">hw.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line">hw.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;上面代码定义了一个简单的 <code>Generator</code> 函数 - <code>helloWorldGenerator</code> ，它的内部有两个 <code>yield</code> 语句 “hello” 和 “world” ,即该函数具有三个状态： hello 、 world 和 return语句。<br>&emsp;&emsp; <code>Generator</code> 函数和一般函数的调用方式相同，都是在函数名之后加上一对圆括号，不同之处在于，调用 <code>Generator</code> 函数之后该函数并不执行，返回的也不是函数的运行结果，而是一个指向内部状态的指针对象，也就是迭代器对象（Iterator Object）。<br>&emsp;&emsp; <code>Generator</code> 接下来就是执行迭代器对象的 <code>next</code> 方法，使得指针指向下一个状态，换句话说，就是每次调用<code>next</code> 方法内部指针都会从函数头部或者当前指针位置开始执行，直到遇到下一个 <code>yield</code> 语句（或者到 <code>return</code> 语句）为止。换言之， <code>Generator</code> 函数是分段执行的，<code>yield</code> 语句是暂停执行的标记，而 <code>next</code> 方法可以恢复函数的执行。<br>&emsp;&emsp;由上面的代码可以看出，当 <code>Generator</code> 函数所有状态都执行完毕之后 <code>done</code> 属性会置为 <code>true</code> ，继续执行的话，<code>value</code> 属性的值会返回 <code>undefned</code> , <code>done</code> 属性依然为 <code>true</code> 。<br>&emsp;&emsp;在ES6 中并没有规定function 关键字和函数名之间的星号写在哪个位置，这导致一下几种写法都能通过：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">foo</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>*<span class="title">foo</span> (<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;由于 <code>Generator</code> 函数仍然是普通函数，所以一般的写法推荐是上面的第一种，即星号紧跟在function关键字后面。    </p><h2 id="yield语句"><a href="#yield语句" class="headerlink" title="yield语句"></a>yield语句</h2><p>&emsp;&emsp;由于 <code>Generator</code> 函数返回的遍历器对象只有调用 <code>next</code> 方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。<code>yield</code> 语句就是暂停标志。<br>&emsp;&emsp;遍历器对象的 <code>next</code> 方法的运行逻辑如下。    </p><ol><li>遇到 <code>yield</code> 语句就暂停执行后面的操作，并将紧跟在 <code>yield</code> 后的表达式的值作为返回的对象的value属性值。    </li><li>下一次调用next方法时再继续往下执行，执行遇到下一条yield语句。</li><li>如果没有再遇到新的yield语句，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值作为返回值作为对象的value属性值。</li><li>如果该函数没有return语句，则返回的value值为undefined。<br>&emsp;&emsp;需要注意的是，yield语句后面的表达式，只有当调用next方法，内部指针指向该语句时才会执行，因此等于为JavaScript提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。    </li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">111</span> + <span class="number">222</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上述代码中，yield后面的表达式 ‘111 + 222’ 不会立即求职，只会在next方法将指针移到这一句的时候才会执行并求职。<br>&emsp;&emsp;yield 和 return的相似之处在于都能返回紧跟在语句后的表达式的值。区别在于每次遇到yield函数暂停执行，下一次会继续从该位置执行，而return不具备位置记忆功能。一个函数只可以执行一次return函数，但是可以执行多个yield状态，因此 <code>Generator</code> 函数可以返回多个状态值。<br>&emsp;&emsp; <code>Generator</code> 可以不用yield语句，这时就变成了一个单纯的暂缓执行函数。<strong>另外注意</strong>，yield不能用于普通函数中，否则会报错。（SyntaxError: Unexpected number）    </p><h2 id="next-方法的参数"><a href="#next-方法的参数" class="headerlink" title="next 方法的参数"></a>next 方法的参数</h2><p>&emsp;&emsp;yield语句本身没有返回值，或者说总返回undefined。next方法可以带一个参数，该参数会被当作上一条yield语句的返回值。<br>&emsp;&emsp; <code>Generator</code> 函数从暂停状态到恢复运行，其上下文状态（context）是不变，通过next方法的参数就有办法在 <code>Generator</code> 运行后继续向函数体内注入值。可以在 <code>Generator</code> 函数运行的不同阶段，从外部向内部注入不同值，从而调整整个函数行为。可以看下下面的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">var</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = foo(<span class="number">5</span>);</span><br><span class="line">a.next() <span class="comment">// Object&#123;value:6, done:false&#125;</span></span><br><span class="line">a.next() <span class="comment">// Object&#123;value:NaN, done:false&#125;</span></span><br><span class="line">a.next() <span class="comment">// Object&#123;value:NaN, done:true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = foo(<span class="number">5</span>);</span><br><span class="line">b.next() <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line">b.next(<span class="number">6</span>) <span class="comment">// &#123; value:4, done:false &#125;</span></span><br><span class="line">b.next(<span class="number">4</span>) <span class="comment">// &#123; value:21, done:true &#125;</span></span><br></pre></td></tr></table></figure></p><blockquote><p>参阅 <a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="noopener">ES 6标准入门 Generator 相关</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;今天在看node.js相关内容的时候，遇到了async/await函数相关，然后想到了promise、generator函数，发现有点记忆混乱了，遂准备整理一下ES6相关的东西。（实际业务中用不到的东西真的是太容易遗忘了，虽然是好东西，能够带来极大的
      
    
    </summary>
    
      <category term="ESx" scheme="http://illuSioN4ng.github.io/categories/ESx/"/>
    
    
      <category term="ESx" scheme="http://illuSioN4ng.github.io/tags/ESx/"/>
    
      <category term="JavaScript" scheme="http://illuSioN4ng.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>命令模式</title>
    <link href="http://illuSioN4ng.github.io/2018/01/10/OPP-command/"/>
    <id>http://illuSioN4ng.github.io/2018/01/10/OPP-command/</id>
    <published>2018-01-10T14:13:48.000Z</published>
    <updated>2018-01-20T09:11:41.665Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<strong>命令模式（Command）</strong>：将请求与实现解耦并封装成独立对象，从而使不同的请求对客户端实现参数化；同事可以对请求排队或者记录请求日志，以及执行可撤销的操作。也就是说改模式旨在将函数的调用、请求和操作封装成一个单一的对象，然后对这个对象进行一系列的处理。<br>&emsp;&emsp;我们来通过车辆购买程序来展示这个模式，首先定义车辆购买的具体操作类：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CarManager = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求信息</span></span><br><span class="line">    requestInfo: <span class="function"><span class="keyword">function</span> (<span class="params">model, id</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'The information for '</span> + model +</span><br><span class="line">    <span class="string">' with ID '</span> + id + <span class="string">' is foobar'</span>;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 购买汽车</span></span><br><span class="line">    buyVehicle: <span class="function"><span class="keyword">function</span> (<span class="params">model, id</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'You have successfully purchased Item '</span></span><br><span class="line">    + id + <span class="string">', a '</span> + model;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组织view</span></span><br><span class="line">    arrangeViewing: <span class="function"><span class="keyword">function</span> (<span class="params">model, id</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'You have successfully booked a viewing of '</span></span><br><span class="line">    + model + <span class="string">' ( '</span> + id + <span class="string">' ) '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;来看一下上述代码，通过调用函数来简单执行manager的命令，然而在一些情况下，我们并不想直接调用对象内部的方法。这样会增加对象与对象间的依赖。现在我们来扩展一下这个CarManager 使其能够接受任何来自包括model和car ID 的CarManager对象的处理请求。根据命令模式的定义，我们希望实现如下这种功能的调用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CarManager.execute(&#123; <span class="attr">commandType</span>: <span class="string">"buyVehicle"</span>, <span class="attr">operand1</span>: <span class="string">'Ford Escort'</span>, <span class="attr">operand2</span>: <span class="string">'453543'</span> &#125;);</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;根据这样的需求，我们可以这样啦实现CarManager.execute方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CarManager.execute = <span class="function"><span class="keyword">function</span> (<span class="params">command</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CarManager[command.request](command.model, command.carID);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;改造以后，调用就简单多了，如下调用都可以实现（当然有些异常细节还是需要再完善一下的）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CarManager.execute(&#123; <span class="attr">request</span>: <span class="string">"arrangeViewing"</span>, <span class="attr">model</span>: <span class="string">'Ferrari'</span>, <span class="attr">carID</span>: <span class="string">'145523'</span> &#125;);</span><br><span class="line">CarManager.execute(&#123; <span class="attr">request</span>: <span class="string">"requestInfo"</span>, <span class="attr">model</span>: <span class="string">'Ford Mondeo'</span>, <span class="attr">carID</span>: <span class="string">'543434'</span> &#125;);</span><br><span class="line">CarManager.execute(&#123; <span class="attr">request</span>: <span class="string">"requestInfo"</span>, <span class="attr">model</span>: <span class="string">'Ford Escort'</span>, <span class="attr">carID</span>: <span class="string">'543434'</span> &#125;);</span><br><span class="line">CarManager.execute(&#123; <span class="attr">request</span>: <span class="string">"buyVehicle"</span>, <span class="attr">model</span>: <span class="string">'Ford Escort'</span>, <span class="attr">carID</span>: <span class="string">'543434'</span> &#125;);</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;命令模式比较容易设计一个命令队列，在需求的情况下比较容易将命令计入日志，并且允许接受请求的一方决定是否需要调用，而且可以实现对请求的撤销和重设，而且由于新增的具体类不影响其他的类，所以很容易实现。<br>&emsp;&emsp;但敏捷开发原则告诉我们，不要为代码添加基于猜测的、实际不需要的功能，如果不清楚一个系统是否需要命令模式，一般就不要着急去实现它，事实上，在需求的时通过重构实现这个模式并不困难，只有在真正需求如撤销、恢复操作等功能时，把原来的代码重构为命令模式才有意义。    </p><blockquote><p>参考: </p><ol><li><a href="http://www.cnblogs.com/TomXu/archive/2012/03/08/2358593.html" target="_blank" rel="noopener">http://www.cnblogs.com/TomXu/archive/2012/03/08/2358593.html</a> </li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;命令模式（Command）&lt;/strong&gt;：将请求与实现解耦并封装成独立对象，从而使不同的请求对客户端实现参数化；同事可以对请求排队或者记录请求日志，以及执行可撤销的操作。也就是说改模式旨在将函数的调用、请求和操作封装成一个单一的对
      
    
    </summary>
    
      <category term="OOP" scheme="http://illuSioN4ng.github.io/categories/OOP/"/>
    
    
      <category term="JavaScript" scheme="http://illuSioN4ng.github.io/tags/JavaScript/"/>
    
      <category term="OOP" scheme="http://illuSioN4ng.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>基于vue-cli的多页配置</title>
    <link href="http://illuSioN4ng.github.io/2018/01/08/vue-vuecli/"/>
    <id>http://illuSioN4ng.github.io/2018/01/08/vue-vuecli/</id>
    <published>2018-01-08T02:07:07.000Z</published>
    <updated>2018-08-26T13:37:48.302Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;最近因为公司中台项目前端技术栈准备整体迁移到vue上，又开始对vue-cli进行了一次相对深入的研究，为项目搭建一个简单的前端开发框架，虽然目前需求的单页应用，不过还是对基于vue-cli的多页应用的配置进行了了解，这篇文章就是进行相关的总结：   </p><h2 id="vue-cli的变化"><a href="#vue-cli的变化" class="headerlink" title="vue-cli的变化"></a>vue-cli的变化</h2><p>&emsp;&emsp;在公司直接安装vue-cli并初始化vue项目的时候，就发现文档目录还是有些许变化的，尤其是build文件夹里少了两个文件，由下面两个图可见：<br><strong>旧版的build文件夹</strong>：<br><img src="http://ww1.sinaimg.cn/large/8c55dc23gy1fn8zj6462jj208e06idfs.jpg" alt="旧版的build文件夹"><br><strong>新版的build文件夹(vue-cli@2.9.2)</strong>：<br><img src="http://ww1.sinaimg.cn/large/8c55dc23gy1fn8zkcmz9mj209005mwef.jpg" alt="新版的build文件夹"><br>&emsp;&emsp;我们知道dev-client.js和dev-server.js文件是之前webpack本地服务热重载hot-reloading，后来想到应该是版本升级之后webpack升级之后使用 <code>webpack-dev-server</code> 进行本地服务的构建了。<br>&emsp;&emsp;打开package.json文件来看：<br><strong>旧版 package.json</strong>:<br><img src="http://ww1.sinaimg.cn/large/8c55dc23gy1fn90jo14erj20ey04mmx8.jpg" alt="旧版 package.json"><br><strong>新版(vue-cli@2.9.2) package.json</strong>：<br><img src="http://ww1.sinaimg.cn/large/8c55dc23gy1fn90k7tws1j20r904q0sv.jpg" alt="新版(vue-cli@2.9.2) package.json"><br>&emsp;&emsp;一看便知，新版 <code>npm run dev</code> 启动的命令与旧版完全不一样了，这也就是为什么新版少了两个文件的原因，新版切换到 <code>webpack-dev-server</code> 来启动本地浏览器。<br>&emsp;&emsp;同时，新版本地服务 <code>npm start</code> 之后浏览器并没有自动打开，显然是配置被默认关闭了，我们改如何去找呢？<br>&emsp;&emsp;首先按照命令调用的js去看 <code>webpack.dev.conf.js</code>：<br><img src="http://ww1.sinaimg.cn/large/8c55dc23gy1fn90xjgspjj20q507jdge.jpg" alt="webpack.dev.conf.js"><br>&emsp;&emsp;这个config又是哪儿来的呢？<br><img src="http://ww1.sinaimg.cn/large/8c55dc23gy1fn90yjeqj1j20fc05lmxi.jpg" alt="webpack.dev.conf.js"><br>&emsp;&emsp;再去看 <code>config</code> 文件夹下的 <code>index.js</code> 文件：<br><img src="http://ww1.sinaimg.cn/large/8c55dc23gy1fn910lmdyqj20w80b4751.jpg" alt="config/index.js"><br>&emsp;&emsp;在这里把 <code>autoOpenBrowser</code> 置为 <code>true</code> 我们在去启动服务（命令行 <code>npm start</code>），这时候浏览器就会自动打开了。    </p><h2 id="基于vue-cli的多页应用配置"><a href="#基于vue-cli的多页应用配置" class="headerlink" title="基于vue-cli的多页应用配置"></a>基于vue-cli的多页应用配置</h2><p>&emsp;&emsp;因为vue-cli默认的就是单页应用的配置，这里就不在赘述。下面详细说下，搭建的多页应用的过程。</p><ol><li><p>首先全局安装<a href="https://github.com/vuejs/vue-cli" target="_blank" rel="noopener">vue-cli</a>    </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i vue-cli -g</span><br></pre></td></tr></table></figure></li><li><p>创建<a href="https://github.com/vuejs-templates" target="_blank" rel="noopener">项目模板</a>：官方提供了六个模板 <code>webpack</code> 、<code>pwa</code> 、 <code>webpack-simple</code> 、 <code>browserify</code> 、 <code>browserify-simple</code> 、 <code>simple</code> ，选择webpack模板    </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack &lt;project-name&gt;</span><br></pre></td></tr></table></figure></li><li><p>在安装过程中会有一些提示：</p><ul><li>Vue build这个选项选择Runtime + Compiler<br><img src="http://ww1.sinaimg.cn/large/8c55dc23gy1fn91ojm8bjj20v604st8y.jpg" alt="Runtime + Compiler"></li><li>安装vue-router，ESLint、Karma+Mocha、Nightwatch根据需求选择安装<br><img src="http://ww1.sinaimg.cn/large/8c55dc23gy1fn91otxqf5j20jh091t95.jpg" alt="其他安装选项"></li><li>安装好依赖之后，根据提示操作，即可成功启动项目    </li></ul></li><li><p>现在创建的项目模板是单页面应用，与多页面应用还有些差别，需要做一些调整：</p><ul><li>项目目录结构调整<br><strong>单页目录</strong>：<br><img src="http://ww1.sinaimg.cn/large/8c55dc23gy1fn952pr92pj20a80dlmxb.jpg" alt="单页目录"><br><strong>多页目录</strong>：<br><img src="http://ww1.sinaimg.cn/large/8c55dc23gy1fn9534vizsj20ah0gjt90.jpg" alt="多页目录"><br>在开发路径src下增加modules和pages文件夹，分别存放模块和页面<br>有关页面的所有文件都放到同一文件夹下就近管理：<code>index.html</code>(页面模板)、<code>main.js</code>(页面入口文件)、<code>App.vue</code>(页面使用的组件，公用组件放到components文件夹下)都移到index文件夹下，并把<code>main.js</code>改为<code>index.js</code>,保证页面的入口js文件和模板文件的名称一致，同时，新建test文件夹（test页面）（多页应用不需要安装<code>vue-router</code>）    </li><li><p>在build/utils.js中添加<code>entries</code>、<code>htmlPlugin</code>两个方法：webpack多入口文件和多页面输出    </p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> PAGE_PATH = path.resolve(__dirname, <span class="string">'../src/pages'</span>)</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'../config'</span>)</span><br><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> packageConfig = <span class="built_in">require</span>(<span class="string">'../package.json'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多入口配置</span></span><br><span class="line">exports.entries = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> entryFiles = glob.sync(PAGE_PATH + <span class="string">'/*/*.js'</span>)</span><br><span class="line">  <span class="keyword">var</span> map = &#123;&#125;</span><br><span class="line">  entryFiles.forEach(<span class="function">(<span class="params">filePath</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> filename = filePath.substring(filePath.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>, filePath.lastIndexOf(<span class="string">'.'</span>))</span><br><span class="line">    map[filename] = filePath</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多页面输出配置</span></span><br><span class="line">exports.htmlPlugin = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> entryHtml = glob.sync(PAGE_PATH + <span class="string">'/*/*.html'</span>)</span><br><span class="line">  <span class="keyword">let</span> arr = []</span><br><span class="line">  entryHtml.forEach(<span class="function">(<span class="params">filePath</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> filename = filePath.substring(filePath.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>, filePath.lastIndexOf(<span class="string">'.'</span>))</span><br><span class="line">    <span class="keyword">let</span> conf = &#123;</span><br><span class="line">      template: filePath,</span><br><span class="line">      filename: filename + <span class="string">'.html'</span>,</span><br><span class="line">      chunks: [ filename ],</span><br><span class="line">      inject: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">      conf = merge(conf, &#123;</span><br><span class="line">        chunks: [ <span class="string">'manifest'</span>, <span class="string">'vendor'</span>, filename ], <span class="comment">//插件对页面入口文件(即js文件)的限定，如果不设置则会把整个项目下的所有入口文件全部引入</span></span><br><span class="line">        <span class="comment">// vendor模块是指提取涉及node_modules中的公共模块</span></span><br><span class="line">        <span class="comment">// manifest模块是对vendor模块做的缓存</span></span><br><span class="line">        minify: &#123;</span><br><span class="line">          removeComments: <span class="literal">true</span>,</span><br><span class="line">          collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">          removeAttributeQuotes: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        chunksSortMode: <span class="string">'dependency'</span> <span class="comment">// 插件会按照模块的依赖关系依次加载，即：manifest，vendor，本页面入口，其他页面入口</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    arr.push(<span class="keyword">new</span> HtmlWebpackPlugin(conf))</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li><li><p>修改build/webpack.base.conf.js的入口配置</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  context: path.resolve(__dirname, <span class="string">'../'</span>),</span><br><span class="line">  <span class="comment">// entry: &#123;</span></span><br><span class="line">  <span class="comment">//   app: './src/main.js'</span></span><br><span class="line">  <span class="comment">// &#125;,</span></span><br><span class="line">  entry: utils.entries(),</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure></li><li><p>修改build/webpack.dev.conf.js和build/webpack.prod.conf.js的多页面配置：把原有的页面模板配置注释或删除，并把多页面配置添加到plugins<br><code>webpack.dev.conf.js</code>:    </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      <span class="string">'process.env'</span>: <span class="built_in">require</span>(<span class="string">'../config/dev.env'</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line">    <span class="keyword">new</span> webpack.NamedModulesPlugin(), <span class="comment">// HMR shows correct file names in console on update.</span></span><br><span class="line">    <span class="keyword">new</span> webpack.NoEmitOnErrorsPlugin(),</span><br><span class="line">    <span class="comment">// https://github.com/ampedandwired/html-webpack-plugin</span></span><br><span class="line">    <span class="comment">// new HtmlWebpackPlugin(&#123;</span></span><br><span class="line">    <span class="comment">//   filename: 'index.html',</span></span><br><span class="line">    <span class="comment">//   template: 'index.html',</span></span><br><span class="line">    <span class="comment">//   inject: true</span></span><br><span class="line">    <span class="comment">// &#125;),</span></span><br><span class="line">    ...utils.htmlPlugin(),</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><code>webpack.prod.conf.js</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">......</span><br><span class="line">  <span class="comment">// generate dist index.html with correct asset hash for caching.</span></span><br><span class="line">  <span class="comment">// you can customize output by editing /index.html</span></span><br><span class="line">  <span class="comment">// see https://github.com/ampedandwired/html-webpack-plugin</span></span><br><span class="line">  <span class="comment">// new HtmlWebpackPlugin(&#123;</span></span><br><span class="line">  <span class="comment">//   filename: config.build.index,</span></span><br><span class="line">  <span class="comment">//   template: 'index.html',</span></span><br><span class="line">  <span class="comment">//   inject: true,</span></span><br><span class="line">  <span class="comment">//   minify: &#123;</span></span><br><span class="line">  <span class="comment">//     removeComments: true,</span></span><br><span class="line">  <span class="comment">//     collapseWhitespace: true,</span></span><br><span class="line">  <span class="comment">//     removeAttributeQuotes: true</span></span><br><span class="line">  <span class="comment">//     // more options:</span></span><br><span class="line">  <span class="comment">//     // https://github.com/kangax/html-minifier#options-quick-reference</span></span><br><span class="line">  <span class="comment">//   &#125;,</span></span><br><span class="line">  <span class="comment">//   // necessary to consistently work with multiple chunks via CommonsChunkPlugin</span></span><br><span class="line">  <span class="comment">//   chunksSortMode: 'dependency'</span></span><br><span class="line">  <span class="comment">// &#125;),</span></span><br><span class="line">  ...utils.htmlPlugin(),</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>&emsp;&emsp;至此，多页面应用已经搭建完毕，只需要在pages文件夹创建相应的页面文件即可，如输入 <code>loaclhost:8080/test.html</code> 即打开 <code>test</code> 文件夹对应的页面，以此类推。<br>&emsp;&emsp;当然，某些业务需求对于url可能需要定制，这时候就需要用到 <code>connect-history-api-fallback</code> api中的 <code>rewrites</code> (<a href="https://github.com/bripkens/connect-history-api-fallback#rewrites" target="_blank" rel="noopener">详情请点击</a>) 选项，如下图配置，就可以实现输入 <code>loaclhost:8080/test</code> 即打开 <code>test</code> 文件夹对应的页面,以及404页面:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  clientLogLevel: <span class="string">'warning'</span>,</span><br><span class="line">  historyApiFallback: &#123;</span><br><span class="line">    <span class="comment">// index: '/test.html', //path.join(config.dev.assetsPublicPath, '/test.html')</span></span><br><span class="line">    <span class="comment">// rewrites: [ &#123; from: /.*/, to: path.join(config.dev.assetsPublicPath, '/index.html') &#125; ]</span></span><br><span class="line">    <span class="comment">// 路由配置，前后端统一</span></span><br><span class="line">    <span class="comment">// 默认 '/' 对应 index.html</span></span><br><span class="line">    rewrites: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">from</span>: <span class="regexp">/^\/test$/</span>,</span><br><span class="line">        to: <span class="string">'/test.html'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">from</span>: <span class="regexp">/.*/</span>,</span><br><span class="line">        to: <span class="string">'/404.html'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;最近因为公司中台项目前端技术栈准备整体迁移到vue上，又开始对vue-cli进行了一次相对深入的研究，为项目搭建一个简单的前端开发框架，虽然目前需求的单页应用，不过还是对基于vue-cli的多页应用的配置进行了了解，这篇文章就是进行相关的总结：   
      
    
    </summary>
    
      <category term="Vue" scheme="http://illuSioN4ng.github.io/categories/Vue/"/>
    
    
      <category term="JavaScript" scheme="http://illuSioN4ng.github.io/tags/JavaScript/"/>
    
      <category term="Vue" scheme="http://illuSioN4ng.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>观察者模式</title>
    <link href="http://illuSioN4ng.github.io/2018/01/07/OOP-observer/"/>
    <id>http://illuSioN4ng.github.io/2018/01/07/OOP-observer/</id>
    <published>2018-01-07T07:19:46.000Z</published>
    <updated>2018-01-20T09:11:41.664Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<strong>观察者模式又叫发布订阅模式（Publish/Subscribe）</strong>，它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。<br>&emsp;&emsp;使用观察者模式的好处：    </p><ol><li>支持简单的广播通信，自动通知所有已经订阅过的对象。</li><li>页面载入后目标对象很容易与观察者存在一种动态关联，增加了灵活性。</li><li>目标对象与观察者之间的抽象耦合关系能够单独扩展以及重用。</li></ol><p>&emsp;&emsp;下面看一个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用代码</span></span><br><span class="line"><span class="keyword">var</span> observer = &#123;</span><br><span class="line">    <span class="comment">//订阅</span></span><br><span class="line">    addSubscriber: <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subscribers[<span class="keyword">this</span>.subscribers.length] = callback;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//退订</span></span><br><span class="line">    removeSubscriber: <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.subscribers.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.subscribers[i] === callback) &#123;</span><br><span class="line">                <span class="keyword">delete</span> (<span class="keyword">this</span>.subscribers[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//发布</span></span><br><span class="line">    publish: <span class="function"><span class="keyword">function</span> (<span class="params">what</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.subscribers.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.subscribers[i] === <span class="string">'function'</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.subscribers[i](what);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 将对象o具有观察者功能</span></span><br><span class="line">    make: <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">            o[i] = <span class="keyword">this</span>[i];</span><br><span class="line">            o.subscribers = [];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后订阅2个对象blogger和user，使用observer.make方法将这2个对象具有观察者功能，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> blogger = &#123;</span><br><span class="line">    writeBlogPost:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> content = <span class="string">'Today is '</span> + <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        <span class="keyword">this</span>.publish(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> la_times = &#123;</span><br><span class="line">    newIssue:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> paper = <span class="string">'Martians have landed on Earth!'</span>;</span><br><span class="line">        <span class="keyword">this</span>.publish(paper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">observer.make(blogger);</span><br><span class="line">observer.make(la_times);</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;使用方法就比较简单了，订阅不同的回调函数，以便可以注册到不同的观察者对象里（也可以同时注册到多个观察者对象里）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jack = &#123;</span><br><span class="line">    read:<span class="function"><span class="keyword">function</span> (<span class="params">what</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'I just read that '</span> + what)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> jill = &#123;</span><br><span class="line">    gossip:<span class="function"><span class="keyword">function</span> (<span class="params">what</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'You didn\'t hear it from me, but '</span> + what)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">blogger.addSubscriber(jack.read);</span><br><span class="line">blogger.addSubscriber(jill.gossip);</span><br><span class="line">blogger.writeBlogPost();    <span class="comment">// I just read that Today is Sun Jan 07 2018 15:38:54 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="comment">// You didn't hear it from me, but Today is Sun Jan 07 2018 15:38:54 GMT+0800 (中国标准时间)</span></span><br><span class="line">blogger.removeSubscriber(jill.gossip);</span><br><span class="line">blogger.writeBlogPost();    <span class="comment">// I just read that Today is Sun Jan 07 2018 15:39:46 GMT+0800 (中国标准时间)</span></span><br><span class="line">la_times.addSubscriber(jill.gossip);</span><br><span class="line">la_times.newIssue();    <span class="comment">// You didn't hear it from me, but Martians have landed on Earth!</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;观察者的使用场合就是：当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象需要改变的时候，就应该考虑使用观察者模式。<br>&emsp;&emsp;总的来说，观察者模式所做的工作就是在解耦，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化。    </p><blockquote><p>参考: </p><ol><li><a href="https://book.douban.com/subject/26382780/" target="_blank" rel="noopener">JavaScript设计模式与开发实践</a> </li><li><a href="https://book.douban.com/subject/26589719/" target="_blank" rel="noopener">JavaScript设计模式</a> </li><li><a href="https://github.com/shichuan/javascript-patterns/blob/master/design-patterns/observer.html" target="_blank" rel="noopener">https://github.com/shichuan/javascript-patterns/blob/master/design-patterns/observer.html</a></li><li><a href="http://www.cnblogs.com/TomXu/archive/2012/03/02/2355128.html" target="_blank" rel="noopener">http://www.cnblogs.com/TomXu/archive/2012/03/02/2355128.html</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;观察者模式又叫发布订阅模式（Publish/Subscribe）&lt;/strong&gt;，它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。&lt;b
      
    
    </summary>
    
      <category term="OOP" scheme="http://illuSioN4ng.github.io/categories/OOP/"/>
    
    
      <category term="JavaScript" scheme="http://illuSioN4ng.github.io/tags/JavaScript/"/>
    
      <category term="OOP" scheme="http://illuSioN4ng.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>迭代器模式</title>
    <link href="http://illuSioN4ng.github.io/2018/01/06/OOP-iterator/"/>
    <id>http://illuSioN4ng.github.io/2018/01/06/OOP-iterator/</id>
    <published>2018-01-06T07:49:56.000Z</published>
    <updated>2018-01-20T09:11:41.664Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<strong>迭代器模式(Iterator)</strong>：提供一种方法顺序一个聚合对象中各个元素，而又不暴露该对象内部表示。<br>&emsp;&emsp;迭代器的几个特点是：    </p><ol><li>访问一个聚合对象的内容而无需暴露它的内部表示。</li><li>为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。</li><li>遍历的同时更改迭代器所在的集合结构可能会导致问题（比如C#的foreach里不允许修改item）。    </li></ol><p>&emsp;&emsp;一般的迭代，至少要有2个方法，hasNext()和Next()，这样才做做到遍历所有对象，可以看下面的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> agg = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span>,</span><br><span class="line">    data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">    length = data.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> element;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            element = data[index];</span><br><span class="line">            index = index + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> element;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        hasNext: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index &lt; length;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        rewind: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        current: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data[index];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">&#125; ());</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;使用方法如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代的结果是：1,3,5</span></span><br><span class="line"><span class="keyword">while</span> (agg.hasNext()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(agg.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;也可以调用重置方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重置</span></span><br><span class="line">agg.rewind();</span><br><span class="line"><span class="built_in">console</span>.log(agg.current()); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;迭代器的使用场景是：对于集合内部结果常常变化各异，我们不想暴露其内部结构的话，但又响让客户代码透明底访问其中的元素，这种情况下我们可以使用迭代器模式。</p><blockquote><p>参考: </p><ol><li><a href="https://book.douban.com/subject/26382780/" target="_blank" rel="noopener">JavaScript设计模式与开发实践</a> </li><li><a href="https://book.douban.com/subject/26589719/" target="_blank" rel="noopener">JavaScript设计模式</a> </li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;迭代器模式(Iterator)&lt;/strong&gt;：提供一种方法顺序一个聚合对象中各个元素，而又不暴露该对象内部表示。&lt;br&gt;&amp;emsp;&amp;emsp;迭代器的几个特点是：    &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;访问一个聚合对象的内容而无需暴
      
    
    </summary>
    
      <category term="OOP" scheme="http://illuSioN4ng.github.io/categories/OOP/"/>
    
    
      <category term="JavaScript" scheme="http://illuSioN4ng.github.io/tags/JavaScript/"/>
    
      <category term="OOP" scheme="http://illuSioN4ng.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>回顾我的2017，展望我的2018</title>
    <link href="http://illuSioN4ng.github.io/2017/12/31/%E5%9B%9E%E9%A1%BE%E6%88%91%E7%9A%842017%EF%BC%8C%E5%B1%95%E6%9C%9B%E6%88%91%E7%9A%842018/"/>
    <id>http://illuSioN4ng.github.io/2017/12/31/回顾我的2017，展望我的2018/</id>
    <published>2017-12-31T07:50:30.000Z</published>
    <updated>2018-01-20T09:11:41.672Z</updated>
    
    <content type="html"><![CDATA[<p>今天是17年最后一天，按照惯例做下年终总结：    </p><h2 id="16年初和17年初定下的目标，和完成的情况"><a href="#16年初和17年初定下的目标，和完成的情况" class="headerlink" title="16年初和17年初定下的目标，和完成的情况"></a>16年初和17年初定下的目标，和完成的情况</h2><h3 id="16年目标"><a href="#16年目标" class="headerlink" title="16年目标"></a>16年目标</h3><ol><li>顺利拿到实习offer（估计要去得和老板撕逼）；<strong>去京东作为前端实习生</strong></li><li>泸沽湖去一次，不去实习的话估计三四月哥们会过来；<strong>没有去成，猴年也没有去峨眉山，蛮遗憾的</strong></li><li>去帝都见见世面，见一次大海，见一见在北方那些可爱的人们；<strong>借着360前端星的机会去了北京，没有见到海，也没有见到想见的人们</strong></li><li>继续运动，目标135，八块腹肌；<strong>15年冬天膝盖受伤之后一直没有跑步，运动的量也减少了，好在坚持篮球，也开始健身了</strong></li><li>继续坚持读书的习惯，读一些让自己轻松的书；<strong><a href="https://book.douban.com/people/illuSioN4ng/collect" target="_blank" rel="noopener">书单</a>  <a href="https://movie.douban.com/people/illuSioN4ng/collect" target="_blank" rel="noopener">电影清单</a></strong></li><li>不脱单，因为不可能所有的都实现，做人不能贪心，对吧？<strong>failed</strong></li></ol><h3 id="17年目标"><a href="#17年目标" class="headerlink" title="17年目标"></a>17年目标</h3><ol><li>顺利毕业；<strong>当然毕业啦</strong></li><li>继续坚持锻炼，体重控制到140； <strong>毕业前差点就到了，工作之后又又又又胖了Orz~</strong></li><li>坚持读书，坚持在豆瓣上记录自己的阅读以及观影列表；（10本技术类，20本非技术类的书籍）<strong>(今年总共读了<a href="https://book.douban.com/people/illuSioN4ng/collect" target="_blank" rel="noopener">书单</a>) 技术类的完整的只有六本吧，还有很多在读的书以及想读的书，来年一定要都读完，读了很多的其他类别的书，感觉收获还是很多的，继续加油</strong></li><li>七月份入职之后，能够胜任自己的工作，爱岗敬业吧；<strong>工作还算顺利</strong></li><li>毕业之后，搬进新家，布置自己的书房，好好生活，带着妈妈旅游两次；<strong>完全没有时间去旅游，希望来年可以更好的陪家人吧</strong></li><li>学习计划的话，可能视情况而定吧，初步是将16年很多想要了解的东西都在毕业前熟悉一下；<strong>工作中对于前端的思考还蛮多的，来年一定要更加多的思考相关的东西，有更好的职业发展道路</strong></li><li>如果可以的话，工作后，希望能给自己买个单反，记录生活的美好。<strong>用奖学金买了微单，但是吃灰比较多~</strong></li><li>对于感情，不奢求了Orz~~~~<strong>嘻嘻，她出现了，挺好</strong></li></ol><h2 id="17年的总结"><a href="#17年的总结" class="headerlink" title="17年的总结"></a>17年的总结</h2><p>毕业季没啥好写的，感觉是至今最有意思的一段经历了。都记在心里啦~<br>然后就是工作上的事情，没有多少意外的事情，感觉和自己之前想到的情况还蛮相似的，希望能够破局，前端工程化、前端工作流、适用于教育BG业务的前端框架、前端工程持续集成、前端监控等等都是我们现在需要去摸索的东西，不知道明年会怎样，要给自己压力去做一些事情，death or rising from the ashes again。<br>读书学习上面还是挺满意的吧，豆瓣书单逐渐变得多起来了。技术类的学习还是在进行，主要依旧是系统性的学习前端还有框架，依旧没有跳出前端，走向编程这个大的领域，希望明年能够走出来并且能够做的更多吧。博客上半年几乎没有怎么动，下半年只有到后期比较闲的时候才开始整，明年加油吧。<br><img src="http://ww1.sinaimg.cn/large/8c55dc23gy1fn00h1lhiij20kd05cdfw.jpg" alt="github contributions last year"></p><h2 id="17年的目标"><a href="#17年的目标" class="headerlink" title="17年的目标"></a>17年的目标</h2><ol><li>工作上能够更加主动，希望能够承担起领导对于自己的期待，以及让自己更加充实起来，给自己压力，逼迫自己去成长；</li><li>生活上，心态更加平和吧，把工作生活学习三者更加好的结合起来，不要彼此影响太多，希望自己更加成熟吧；</li><li>布置好自己的工作台，期待了很久很久了；</li><li>读书方面，读完自己囤的一堆书，找一些经济学、行为学的书来读，扩展自己的知识面吧，不要被别人幸存者偏差误导，对生活对未来要有着自己的更加体系化的判断；</li><li>好好经营自己和笨笨的感情吧，很乖巧的一个女孩。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天是17年最后一天，按照惯例做下年终总结：    &lt;/p&gt;
&lt;h2 id=&quot;16年初和17年初定下的目标，和完成的情况&quot;&gt;&lt;a href=&quot;#16年初和17年初定下的目标，和完成的情况&quot; class=&quot;headerlink&quot; title=&quot;16年初和17年初定下的目标，和
      
    
    </summary>
    
      <category term="年终总结" scheme="http://illuSioN4ng.github.io/categories/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="2017总结 &amp;&amp; 2018展望" scheme="http://illuSioN4ng.github.io/tags/2017%E6%80%BB%E7%BB%93-2018%E5%B1%95%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>代理模式</title>
    <link href="http://illuSioN4ng.github.io/2017/12/24/OOP-proxy/"/>
    <id>http://illuSioN4ng.github.io/2017/12/24/OOP-proxy/</id>
    <published>2017-12-24T14:22:45.000Z</published>
    <updated>2018-01-20T09:11:41.665Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<strong>代理模式（Proxy）</strong>：由于一个对象不能直接引用另一个对象，所以需要通过迭代对象在两个对象之间起到中介的作用。<br>&emsp;&emsp;实际的编程中， 因为性能问题使用代理模式的机会是非常多的。比如频繁的访问dom节点, 频繁的请求远程资源. 可以把操作先存到一个缓冲区, 然后自己选择真正的触发时机。<br>&emsp;&emsp;还有个例子就是在调用ajax请求的时候，无论是各种开源库，还是自己写的Ajax类, 都会给xhr对象设置一个代理. 我们不可能频繁的去操作xhr对象发请求, 而应该是这样。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = Ajax.get( <span class="string">'cgi.xx.com/xxx'</span> );</span><br><span class="line">request.send();</span><br><span class="line">request.done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp; 代理对象可以完全解决被代理对象与外界对象之间的耦合，当然从被代理的页面角度来看是一种保护代理，而从服务器角度来看是一种远程代理。除了上述的几种应用外，还有以下一些常用的应用场景：<br>代理模式一般适用于如下场合：</p><ol><li>远程代理，也就是为了一个对象在不同的地址空间提供局部代表，这样可以隐藏一个对象存在于不同地址空间的事实，就像web service里的代理类一样。</li><li>虚拟代理，根据需要创建开销很大的对象，通过它来存放实例化需要很长时间的真实对象，比如浏览器的渲染的时候先显示问题，而图片可以慢慢显示（就是通过虚拟代理代替了真实的图片，此时虚拟代理保存了真实图片的路径和尺寸。</li><li>安全代理，用来控制真实对象访问时的权限，一般用于对象应该有不同的访问权限。</li><li>智能指引，只当调用真实的对象时，代理处理另外一些事情。例如C#里的垃圾回收，使用对象的时候会有引用次数，如果对象没有引用了，GC就可以回收它了。</li></ol><blockquote><p>参考: </p><ol><li><a href="https://book.douban.com/subject/26382780/" target="_blank" rel="noopener">JavaScript设计模式与开发实践</a> </li><li><a href="https://book.douban.com/subject/26589719/" target="_blank" rel="noopener">JavaScript设计模式</a> </li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;代理模式（Proxy）&lt;/strong&gt;：由于一个对象不能直接引用另一个对象，所以需要通过迭代对象在两个对象之间起到中介的作用。&lt;br&gt;&amp;emsp;&amp;emsp;实际的编程中， 因为性能问题使用代理模式的机会是非常多的。比如频繁的访问d
      
    
    </summary>
    
      <category term="OOP" scheme="http://illuSioN4ng.github.io/categories/OOP/"/>
    
    
      <category term="JavaScript" scheme="http://illuSioN4ng.github.io/tags/JavaScript/"/>
    
      <category term="OOP" scheme="http://illuSioN4ng.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="http://illuSioN4ng.github.io/2017/12/17/OOP-strategy/"/>
    <id>http://illuSioN4ng.github.io/2017/12/17/OOP-strategy/</id>
    <published>2017-12-17T06:02:56.000Z</published>
    <updated>2018-01-20T09:11:41.665Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在我们的实际业务中经常会遇到很多分支判断的情况，包括商城根据用户会员等级的促销折扣、根据绩效等级的年终奖金计算，这些情况下的每种分支的业务都是类似的，只是对于具体业务的具体处理过程或者算法的不同，导致最终的效果不同。各分支之间都是平级关系，这种情况下我们可以采用策略模式，来解决算法和使用者之间的耦合。<br>&emsp;&emsp;策略模式的定义是：定义一系列的算法，把它们一个一个封装起来，并且使它们可以相互替换。    </p><h2 id="使用策略模式计算奖金"><a href="#使用策略模式计算奖金" class="headerlink" title="使用策略模式计算奖金"></a>使用策略模式计算奖金</h2><h3 id="最原始的代码实现"><a href="#最原始的代码实现" class="headerlink" title="最原始的代码实现"></a>最原始的代码实现</h3><p>&emsp;&emsp;我们编写一个名为 <code>calculateBonus</code> 的函数来计算每个人的年终奖金。显然，改函数需要两个参数：员工的工资数额和他的绩效考核等级。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> calculateBonus = <span class="function"><span class="keyword">function</span>(<span class="params"> performanceLevel, salary </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( performanceLevel === <span class="string">'S'</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( performanceLevel === <span class="string">'A'</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( performanceLevel === <span class="string">'B'</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">calculateBonus( <span class="string">'B'</span>, <span class="number">20000</span> ); <span class="comment">// 返回：40000</span></span><br><span class="line">calculateBonus( <span class="string">'S'</span>, <span class="number">6000</span> ); <span class="comment">// 返回：24000</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可以看出元时代吗中存在着显而易见的缺点：</p><ul><li><code>calculateBonus</code> 函数会随着绩效考核等级的增加而不断变得臃肿起来， <code>if-else</code> 语句会越变越多；</li><li><code>calculateBonus</code> 函数缺乏弹性，每增加一种绩效等级或者是改变一个绩效等级的奖金系数，我们都必须深入到函数内部去进行查找并修改；</li><li>函数的复用性差。</li></ul><p>&emsp;&emsp;因此我们就需要重构这一部分代码。</p><h3 id="使用组合函数的方式重构代码"><a href="#使用组合函数的方式重构代码" class="headerlink" title="使用组合函数的方式重构代码"></a>使用组合函数的方式重构代码</h3><p>&emsp;&emsp;重构最简单的方式就是使用组合函数来进行，我们把各种算法封装到一个一个的小函数中，使用一些良好的命名规范，可以一目了然地知道它对应的算法，他们也可以复用到程序的其他地方。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> performanceS = <span class="function"><span class="keyword">function</span>(<span class="params"> salary </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> performanceA = <span class="function"><span class="keyword">function</span>(<span class="params"> salary </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> performanceB = <span class="function"><span class="keyword">function</span>(<span class="params"> salary </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> calculateBonus = <span class="function"><span class="keyword">function</span>(<span class="params"> performanceLevel, salary </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( performanceLevel === <span class="string">'S'</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> performanceS( salary );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( performanceLevel === <span class="string">'A'</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> performanceA( salary );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( performanceLevel === <span class="string">'B'</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> performanceB( salary );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">calculateBonus( <span class="string">'A'</span> , <span class="number">10000</span> ); <span class="comment">// 返回：30000</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;采用组合函数的方式我们解决了功能复用的问题，但是还是没有解决函数变得越来越臃肿的可能以及缺乏弹性的事实。</p><h3 id="使用策略模式"><a href="#使用策略模式" class="headerlink" title="使用策略模式"></a>使用策略模式</h3><p>&emsp;&emsp;正如上文中提到的策略模式的定义：定义一系列的算法，把它们一个一个封装起来。将不变与变的部分隔离开是每个设计模式的主题，策略模式也不例外，策略模式的目的就是将函数的使用和函数的实现隔离开。<br>&emsp;&emsp;一个基于策略模式的程序至少由两部分组成，第一部分是预测策略类，用来封装具体的算法，并负责计算过程；第二部分是环境<code>context</code>类，接受到用户的请求后，随后将该请求委托给具体的某一个策略类。所以在 <code>context</code> 中要维持对某个策略对象的引用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> performanceS = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">performanceS.prototype.calculate = <span class="function"><span class="keyword">function</span>(<span class="params"> salary </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> performanceA = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">performanceA.prototype.calculate = <span class="function"><span class="keyword">function</span>(<span class="params"> salary </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> performanceB = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">performanceB.prototype.calculate = <span class="function"><span class="keyword">function</span>(<span class="params"> salary </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来定义奖金类Bonus：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Bonus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.salary = <span class="literal">null</span>; <span class="comment">// 原始工资</span></span><br><span class="line">    <span class="keyword">this</span>.strategy = <span class="literal">null</span>; <span class="comment">// 绩效等级对应的策略对象</span></span><br><span class="line">&#125;;</span><br><span class="line">Bonus.prototype.setSalary = <span class="function"><span class="keyword">function</span>(<span class="params"> salary </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.salary = salary; <span class="comment">// 设置员工的原始工资</span></span><br><span class="line">&#125;;</span><br><span class="line">Bonus.prototype.setStrategy = <span class="function"><span class="keyword">function</span>(<span class="params"> strategy </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.strategy = strategy; <span class="comment">// 设置员工绩效等级对应的策略对象</span></span><br><span class="line">&#125;;</span><br><span class="line">Bonus.prototype.getBonus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 取得奖金数额</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.strategy.calculate( <span class="keyword">this</span>.salary ); <span class="comment">// 把计算奖金的操作委托给对应的策略对象</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bonus = <span class="keyword">new</span> Bonus();</span><br><span class="line">bonus.setSalary( <span class="number">10000</span> );</span><br><span class="line"></span><br><span class="line">bonus.setStrategy( <span class="keyword">new</span> performanceS() ); <span class="comment">// 设置策略对象</span></span><br><span class="line"><span class="built_in">console</span>.log( bonus.getBonus() ); <span class="comment">// 输出：40000</span></span><br><span class="line">bonus.setStrategy( <span class="keyword">new</span> performanceA() ); <span class="comment">// 设置策略对象</span></span><br><span class="line"><span class="built_in">console</span>.log( bonus.getBonus() ); <span class="comment">// 输出：30000</span></span><br><span class="line"><span class="string">``</span><span class="string">`    </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&amp;emsp;&amp;emsp;上文中的 `</span>context<span class="string">` 类就是 `</span>bonus<span class="string">` ， `</span>performanceX<span class="string">` 类就是一个策略类，代表绩效等级 `</span>X<span class="string">` 的策略方法。    </span></span><br><span class="line"><span class="string">&amp;emsp;&amp;emsp;虽然已经对于代码进行了相应的重构，不过该段代码是基于传统的面向对象语言来实现的，在 `</span>JavaScript<span class="string">` 中有更加简单的方式去实现。    </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## JavaScript中的策略模式</span></span><br><span class="line"><span class="string">&amp;emsp;&amp;emsp;Talk is cheap,show you code.    </span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="keyword">var</span> strategies = &#123;</span><br><span class="line"><span class="string">"S"</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> salary </span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> salary * <span class="number">4</span>;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"A"</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> salary </span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> salary * <span class="number">3</span>;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"B"</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> salary </span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> salary * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> calculateBonus = <span class="function"><span class="keyword">function</span>(<span class="params"> level, salary </span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> strategies[ level ]( salary );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( calculateBonus( <span class="string">'S'</span>, <span class="number">20000</span> ) ); <span class="comment">// 输出：80000</span></span><br><span class="line"><span class="built_in">console</span>.log( calculateBonus( <span class="string">'A'</span>, <span class="number">10000</span> ) ); <span class="comment">// 输出：30000</span></span><br></pre></td></tr></table></figure><h2 id="策略模式的优缺点"><a href="#策略模式的优缺点" class="headerlink" title="策略模式的优缺点"></a>策略模式的优缺点</h2><p>&emsp;&emsp;测试模式是一种有效的设计模式，在上述的描述中，我们不难看出策略模式的一些优缺点。    </p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>策略模式利用组合、委托和多态等技术和思想，可以有效地避免多重条件选择语句；</li><li>策略模式封装了一些策略类，将算法封装在独立的 <code>strategy</code> 中，使得它们之间易切换、理解、扩展；</li><li>策略模式中的策略类易于复用，从而避免了许多复制粘贴修改的工作；</li><li>使用组合和委托来让 <code>context</code> 类拥有执行算法的能力，这也是继承的一种更有效的替代方案。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>选择使用的 <code>strategy</code> 的决定权在用户，所以用户必须了解所有的 <code>strategy</code> 的作用，这样才能找到一个合适的 <code>strategy</code> ，这增加了使用成本；</li><li>因为策略模式中的 <code>strategy</code> 都是独立封装的，所以一些复杂算法中处理相同逻辑部分也不能公用，所以我们需要采用一些其他的方案来辅助。</li></ul><blockquote><p>参考: </p><ol><li><a href="https://book.douban.com/subject/26382780/" target="_blank" rel="noopener">JavaScript设计模式与开发实践</a> </li><li><a href="https://book.douban.com/subject/26589719/" target="_blank" rel="noopener">JavaScript设计模式</a> </li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;在我们的实际业务中经常会遇到很多分支判断的情况，包括商城根据用户会员等级的促销折扣、根据绩效等级的年终奖金计算，这些情况下的每种分支的业务都是类似的，只是对于具体业务的具体处理过程或者算法的不同，导致最终的效果不同。各分支之间都是平级关系，这种情况下
      
    
    </summary>
    
      <category term="OOP" scheme="http://illuSioN4ng.github.io/categories/OOP/"/>
    
    
      <category term="JavaScript" scheme="http://illuSioN4ng.github.io/tags/JavaScript/"/>
    
      <category term="OOP" scheme="http://illuSioN4ng.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://illuSioN4ng.github.io/2017/12/03/OOP-singleleton/"/>
    <id>http://illuSioN4ng.github.io/2017/12/03/OOP-singleleton/</id>
    <published>2017-12-03T08:11:45.000Z</published>
    <updated>2018-01-20T09:11:41.665Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;单例模式的定义为：保证一个类只有一个实例，并提供一个访问它的全局访问点。<br>&emsp;&emsp;单例模式的经典实现方式是，创建一个类，这个类包含一个方法，这个方法在没有对象存在的情况下，将会创建一个新的实例对象。如果对象存在，这个方法只是返回这个对象的引用。<br>&emsp;&emsp;单例模式是一种常用的模式，有一些对象我们往往只允许一个存在，例如：线程池、全局缓存、浏览器中的window对象和node中的global对象等等。还有实际开发中的某个登录框弹框，并非所有用户都是需要登录的，所以我们并不见得需要将弹出框布局写死在HTML中，只需要在JavaScript中第一次登录请求的时候的时时候写入且仅写入一次。<br>&emsp;&emsp;下面我们来看一下最简单的一种单例模式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mySingleton = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Instance stores a reference to the Singleton</span></span><br><span class="line">  <span class="keyword">var</span> instance;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有方法和变量</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateMethod</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"I am private"</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="string">"Im also private"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> privateRandomNumber = <span class="built_in">Math</span>.random();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 共有方法和变量</span></span><br><span class="line">      publicMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"The public can see me!"</span> );</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      publicProperty: <span class="string">"I am also public"</span>,</span><br><span class="line"></span><br><span class="line">      getRandomNumber: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> privateRandomNumber;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果存在获取此单例实例，如果不存在创建一个单例实例</span></span><br><span class="line">    getInstance: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ( !instance ) &#123;</span><br><span class="line">        instance = init();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;返回的<code>getInstance</code>函数中判断<code>if ( !instance )</code>这步操作就是判断实例是否存在，从而控制实例只有一个。如果存在实例的话就返回该实例的引用。   </p><blockquote><p>参考: </p><ol><li><a href="https://book.douban.com/subject/26382780/" target="_blank" rel="noopener">JavaScript设计模式与开发实践</a> </li><li><a href="https://book.douban.com/subject/26589719/" target="_blank" rel="noopener">JavaScript设计模式</a> </li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;单例模式的定义为：保证一个类只有一个实例，并提供一个访问它的全局访问点。&lt;br&gt;&amp;emsp;&amp;emsp;单例模式的经典实现方式是，创建一个类，这个类包含一个方法，这个方法在没有对象存在的情况下，将会创建一个新的实例对象。如果对象存在，这个方法只是返回
      
    
    </summary>
    
      <category term="OOP" scheme="http://illuSioN4ng.github.io/categories/OOP/"/>
    
    
      <category term="JavaScript" scheme="http://illuSioN4ng.github.io/tags/JavaScript/"/>
    
      <category term="OOP" scheme="http://illuSioN4ng.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>underscore-js源码阅读（3）</title>
    <link href="http://illuSioN4ng.github.io/2017/11/12/underscore-js%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%883%EF%BC%89/"/>
    <id>http://illuSioN4ng.github.io/2017/11/12/underscore-js源码阅读（3）/</id>
    <published>2017-11-12T07:16:28.000Z</published>
    <updated>2018-01-20T09:11:41.671Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;今天准备来写一下 <code>underscore.js</code> 里面判断两个参数相等的 <code>_.isEqual</code> 函数。这里的相等的含义，简单举例来说就是 <code>1</code> 和 <code>new Number(1)</code> 被认为是 <code>equal</code>，<code>[1]</code> 和 <code>[1]</code> 也被认为是 <code>equal</code>（尽管它们的引用并不相同），当然，两个引用相同的对象肯定是 equal 的了。<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Perform a deep comparison to<span class="built_in"> check </span>if two objects are equal.</span><br><span class="line">  _.isEqual = function(a, b) &#123;</span><br><span class="line">   <span class="built_in"> return </span>eq(a, b);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><p>&emsp;由上面的代码可以看出，主要的实现是在 <code>eq</code> 函数中。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">eq = <span class="function"><span class="keyword">function</span>(<span class="params">a, b, aStack, bStack</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Identical objects are equal. `0 === -0`, but they aren't identical.</span></span><br><span class="line">    <span class="comment">// See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).</span></span><br><span class="line">    <span class="comment">//这里恒等判断中要注意 0 === -0，但是我们认为他们是不相等的</span></span><br><span class="line">    <span class="keyword">if</span> (a === b) <span class="keyword">return</span> a !== <span class="number">0</span> || <span class="number">1</span> / a === <span class="number">1</span> / b;</span><br><span class="line">    <span class="comment">// `null` or `undefined` only equal to itself (strict comparison).</span></span><br><span class="line">    <span class="comment">//这里是判断 a 或者 b 中有 `null` 或者 `undefined` 的情况，直接返回 `false`</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span> || b == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// `NaN`s are equivalent, but non-reflexive.</span></span><br><span class="line">    <span class="comment">// `NaN` 在js中是不相等的，但是我们在这里视为相等</span></span><br><span class="line">    <span class="keyword">if</span> (a !== a) <span class="keyword">return</span> b !== b;</span><br><span class="line">    <span class="comment">// Exhaust primitive checks</span></span><br><span class="line">    <span class="comment">// 这里这部分没太懂，以后来填坑</span></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">type</span> = <span class="keyword">typeof</span> a;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">type</span> !== <span class="string">'function'</span> &amp;&amp; <span class="keyword">type</span> !== <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> b != <span class="string">'object'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> deepEq(a, b, aStack, bStack);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><p>&emsp;接下来返回一个 <code>deepEq</code> 函数利用 <code>Object.prototype.toString.call</code> 来判断对象类型，如下所示：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Internal recursive comparison function for `isEqual`.</span></span><br><span class="line">  deepEq = <span class="function"><span class="keyword">function</span><span class="params">(a, b, aStack, bStack)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Unwrap any wrapped objects.</span></span><br><span class="line">    <span class="keyword">if</span> (a <span class="keyword">instanceof</span> _) a = a._wrapped;</span><br><span class="line">    <span class="keyword">if</span> (b <span class="keyword">instanceof</span> _) b = b._wrapped;</span><br><span class="line">    <span class="comment">// Compare `[[Class]]` names.</span></span><br><span class="line">    <span class="keyword">var</span> className = toString.call(a);</span><br><span class="line">    <span class="keyword">if</span> (className !== toString.call(b)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">switch</span> (className) &#123;</span><br><span class="line">      <span class="comment">// Strings, numbers, regular expressions, dates, and booleans are compared by value.</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'[object RegExp]'</span>:</span><br><span class="line">      <span class="comment">// RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')</span></span><br><span class="line">      <span class="comment">// 将正则表达式转换成字符串进行比较</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'[object String]'</span>:</span><br><span class="line">        <span class="comment">// Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is</span></span><br><span class="line">        <span class="comment">// equivalent to `new String("5")`.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span> + a === <span class="string">''</span> + b;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'[object Number]'</span>:</span><br><span class="line">        <span class="comment">// `NaN`s are equivalent, but non-reflexive.</span></span><br><span class="line">        <span class="comment">// Object(NaN) is equivalent to NaN.</span></span><br><span class="line">        <span class="keyword">if</span> (+a !== +a) <span class="keyword">return</span> +b !== +b;</span><br><span class="line">        <span class="comment">// An `egal` comparison is performed for other numeric values.</span></span><br><span class="line">        <span class="keyword">return</span> +a === <span class="number">0</span> ? <span class="number">1</span> / +a === <span class="number">1</span> / b : +a === +b;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'[object Date]'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'[object Boolean]'</span>:</span><br><span class="line">        <span class="comment">// Coerce dates and booleans to numeric primitive values. Dates are compared by their</span></span><br><span class="line">        <span class="comment">// millisecond representations. Note that invalid dates with millisecond representations</span></span><br><span class="line">        <span class="comment">// of `NaN` are not equivalent.</span></span><br><span class="line">        <span class="comment">// 数字和boolean均转换成数字进行比较</span></span><br><span class="line">        <span class="keyword">return</span> +a === +b;</span><br><span class="line">        <span class="comment">// 这里还新增了对于 `Symbol` 的支持</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'[object Symbol]'</span>:</span><br><span class="line">        <span class="keyword">return</span> SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组和对象的比较，就运用到了递归的运用了，有些许复杂，用心去理解就好啦</span></span><br><span class="line">    <span class="keyword">var</span> areArrays = className === <span class="string">'[object Array]'</span>;</span><br><span class="line">    <span class="keyword">if</span> (!areArrays) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> a != <span class="string">'object'</span> || <span class="keyword">typeof</span> b != <span class="string">'object'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Objects with different constructors are not equivalent, but `Object`s or `Array`s</span></span><br><span class="line">      <span class="comment">// from different frames are.</span></span><br><span class="line">      <span class="keyword">var</span> aCtor = a.constructor, bCtor = b.constructor;</span><br><span class="line">      <span class="keyword">if</span> (aCtor !== bCtor &amp;&amp; !(_.isFunction(aCtor) &amp;&amp; aCtor <span class="keyword">instanceof</span> aCtor &amp;&amp;</span><br><span class="line">                               _.isFunction(bCtor) &amp;&amp; bCtor <span class="keyword">instanceof</span> bCtor)&amp;&amp; </span><br><span class="line">                              (<span class="string">'constructor'</span> <span class="keyword">in</span> a &amp;&amp; <span class="string">'constructor'</span> <span class="keyword">in</span> b)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Assume equality for cyclic structures. The algorithm for detecting cyclic</span></span><br><span class="line">    <span class="comment">// structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initializing stack of traversed objects.</span></span><br><span class="line">    <span class="comment">// It's done here since we only need them for objects and arrays comparison.</span></span><br><span class="line">    aStack = aStack || [];</span><br><span class="line">    bStack = bStack || [];</span><br><span class="line">    <span class="keyword">var</span> length = aStack.length;</span><br><span class="line">    <span class="keyword">while</span> (length--) &#123;</span><br><span class="line">      <span class="comment">// Linear search. Performance is inversely proportional to the number of</span></span><br><span class="line">      <span class="comment">// unique nested structures.</span></span><br><span class="line">      <span class="keyword">if</span> (aStack[length] === a) <span class="keyword">return</span> bStack[length] === b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the first object to the stack of traversed objects.</span></span><br><span class="line">    aStack.push(a);</span><br><span class="line">    bStack.push(b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recursively compare objects and arrays.</span></span><br><span class="line">    <span class="keyword">if</span> (areArrays) &#123;</span><br><span class="line">      <span class="comment">// Compare array lengths to determine if a deep comparison is necessary.</span></span><br><span class="line">      length = a.length;</span><br><span class="line">      <span class="keyword">if</span> (length !== b.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">// Deep compare the contents, ignoring non-numeric properties.</span></span><br><span class="line">      <span class="keyword">while</span> (length--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!eq(a[length], b[length], aStack, bStack)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Deep compare objects.</span></span><br><span class="line">      <span class="keyword">var</span> keys = _.keys(a), key;</span><br><span class="line">      length = keys.length;</span><br><span class="line">      <span class="comment">// Ensure that both objects contain the same number of properties before comparing deep equality.</span></span><br><span class="line">      <span class="keyword">if</span> (_.keys(b).length !== length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">while</span> (length--) &#123;</span><br><span class="line">        <span class="comment">// Deep compare each member</span></span><br><span class="line">        key = keys[length];</span><br><span class="line">        <span class="keyword">if</span> (!(_.has(b, key) &amp;&amp; eq(a[key], b[key], aStack, bStack))) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Remove the first object from the stack of traversed objects.</span></span><br><span class="line">    aStack.pop();</span><br><span class="line">    bStack.pop();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><p>&emsp;这部分的内容基本上也就说完了，仅仅记录一下自己注意到的东西，也有很多不太清楚的细节处理，慢慢积累吧，以后会回来补坑的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;今天准备来写一下 &lt;code&gt;underscore.js&lt;/code&gt; 里面判断两个参数相等的 &lt;code&gt;_.isEqual&lt;/code&gt; 函数。这里的相等的含义，简单举例来说就是 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;new Number(1)&lt;/c
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://illuSioN4ng.github.io/categories/JavaScript/"/>
    
    
      <category term="underscore.js" scheme="http://illuSioN4ng.github.io/tags/underscore-js/"/>
    
  </entry>
  
</feed>
